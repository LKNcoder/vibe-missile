<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <!-- Additional meta tag to encourage landscape orientation -->
    <meta name="screen-orientation" content="landscape">
    <meta name="x5-orientation" content="landscape">
    <meta name="msapplication-orientation" content="landscape">
   
    <title>Vibe Missile</title>
   
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Quantico:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #startMenu, #gameOverScreen {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        color: white;
        background-color: rgba(0, 0, 0, 0.85);
        padding: 40px;
        border-radius: 8px;
        z-index: 100;
        width: 450px;
        box-shadow: 0 0 40px rgba(255, 0, 0, 0.3), 
                    inset 0 0 20px rgba(255, 0, 0, 0.2);
        border: 2px solid #444;
        font-family: 'Quantico', sans-serif;
    }

    #startMenu h1, #gameOverScreen h2 {
        font-family: 'Black Ops One', cursive;
        font-size: 42px;
        text-transform: uppercase;
        margin-top: 0;
        margin-bottom: 20px;
        text-shadow: 0 0 10px rgba(255, 0, 0, 0.7);
        letter-spacing: 2px;
    }
    
    #gameOverScreen h2 {
        font-size: 46px;
        color: #ff3333;
    }
    
    #settingsBtn {
    transition: transform 0.2s, background 0.2s;
}

#settingsBtn:hover {
    transform: scale(1.1) rotate(30deg);
    background: rgba(255, 51, 51, 0.5);
}

#settingsSaveBtn:hover {
    background: #ff6666;
}

#settingsCancelBtn:hover {
    background: rgba(100, 100, 100, 0.3);
    color: white;
}

.settings-color-button:hover {
    transform: scale(1.2);
    z-index: 10;
}

    
    /* Add decorative elements to the UI */
    #startMenu:before, #gameOverScreen:before {
        content: "";
        position: absolute;
        top: 10px;
        left: 10px;
        right: 10px;
        bottom: 10px;
        border: 1px dashed rgba(255, 255, 255, 0.3);
        pointer-events: none;
    }
    
    /* Add military corner decorations */
    .corner-decoration {
        position: absolute;
        width: 30px;
        height: 30px;
        border: 3px solid #ff3333;
        opacity: 0.7;
    }
    
    .top-left {
        top: 10px;
        left: 10px;
        border-right: none;
        border-bottom: none;
    }
    
    .top-right {
        top: 10px;
        right: 10px;
        border-left: none;
        border-bottom: none;
    }
    
    .bottom-left {
        bottom: 10px;
        left: 10px;
        border-right: none;
        border-top: none;
    }
    
    .bottom-right {
        bottom: 10px;
        right: 10px;
        border-left: none;
        border-top: none;
    }
        
    #hud {
            font-family: 'Quantico', sans-serif;
            padding: 20px 5px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 1px solid #ff3333;
            border-radius: 5px;
            color: white;
            min-width: 250px;
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 18px; /* Increased font size */
        }
        .hud-row span:first-child {
            margin-right: 20px;
            color: #aaaaaa;
            font-weight: bold;
        }
        
        #direction, #speed, #altitude {
            color: #66ccff;
            font-size: 22px; /* Even bigger for values */
            font-weight: bold;
        }

        .hud-row {
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
        }
        #minimap {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 450px;
            height: 450px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            border: 2px solid #000;
            overflow: hidden;
        }
        #leaderboard {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            font-family: 'Quantico', sans-serif;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #ff3333;
            width: 200px;
            z-index: 1000;
        }
        
        .leaderboard-title {
            text-align: center;
            margin-bottom: 12px;
            font-size: 20px;
            color: #ffffff;
            border-bottom: 1px solid #555;
            padding-bottom: 8px;
            font-weight: bold;
        }
        
        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .leaderboard-table th {
            text-align: left;
            padding: 8px;
            color: #aaaaaa;
            border-bottom: 1px solid #444;
        }
        
        .leaderboard-table td {
            padding: 8px;
            border-bottom: 1px solid #333;
        }
        
        .leaderboard-table tr.you {
            background-color: rgba(255, 51, 51, 0.3);
        }
        
        .leaderboard-table .tpm {
            font-weight: bold;
            color: #ffcc00;
        }
        
        .leaderboard-table .name {
            max-width: 150px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        @keyframes highlight {
            0% { background-color: rgba(255, 204, 0, 0.4); }
            100% { background-color: transparent; }
        }
        
        
        .highlight {
            animation: highlight 1.5s;
        }

        .leaderboard-header {
        justify-content: flex-start;
        font-size: 14px;
        padding: 4px 8px;
        margin-bottom: 5px;
        color: #aaaaaa;
        border-bottom: 1px solid #444;
        display: flex;
        font-weight: bold;
    }
    
    .leaderboard-row {
        justify-content: flex-start;
        padding: 4px 8px;
        margin-bottom: 2px;
        border-radius: 3px;
        font-size: 14px;
        display: flex;
        align-items: center;
        border-left: 3px solid transparent;
    }
    
    .player-row {
        border-left: 3px solid #ff3333;
        background: rgba(255, 51, 51, 0.1);
    }
    
    .leaderboard-row.highlight {
        animation: highlight-pulse 1.5s ease-out;
    }
    
    @keyframes highlight-pulse {
        0% { background-color: rgba(255, 255, 255, 0.3); }
        100% { background-color: transparent; }
    }
    
    @keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}
    
    .name-col {
        flex-grow: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        font-weight: bold;
        max-width: 125px; /* Give more space for names now that TPM is gone */
    }
    
    .score-col {
        width: 60px;
        text-align: right;
        margin-right: 15px;
        font-weight: bold;
    }

    #controlsOverlay {
    position: absolute;
    top: 65%;  
    left: 50%;
    transform: translateX(-50%);
    color: white;
    padding: 20px;
    text-align: center;
    z-index: 100;
    font-family: 'Quantico', sans-serif;
    opacity: 0;
    transition: opacity 0.5s;
    max-width: 600px;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8), 
                 0 0 10px rgba(0, 0, 0, 0.7);
    font-size: 20px;
    font-weight: bold;
    letter-spacing: 0.5px;
}

#controlsOverlay h3 {
    margin-top: 0;
    color: #ff3333;
}

.control-row {
    display: flex;
    justify-content: space-between;
    margin: 10px 0;
}

.key {
    background-color: #333;
    padding: 5px 10px;
    border-radius: 5px;
    margin-right: 10px;
    border: 1px solid #555;
    font-family: monospace;
    font-weight: bold;
}

#colorButtons {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    max-width: 350px;
    margin-bottom: 15px;
    gap: 12px; /* Increased gap to prevent overlap */
    position: relative; /* Create stacking context */
}

.color-button {
    width: 30px;
    height: 30px;
    border-radius: 5px;
    cursor: pointer;
    border: 2px solid #333;
    transition: transform 0.2s, border-color 0.2s;
    transform-origin: center center; /* Ensure transform from center */
    position: relative; /* Keep position context */
    z-index: 1; /* Start with lower z-index */
}

.color-button:hover {
    transform: scale(1.15);
    z-index: 100; /* Much higher when hovered to ensure it's above others */
}

.color-button.selected {
    border-color: #ffffff;
    box-shadow: 0 0 8px rgba(255, 255, 255, 0.8);
    z-index: 50; /* Higher than regular but lower than hovered */
}

#missilePreviewContainer {
    width: 200px;
    height: 200px;
    background-color: rgba(0, 0, 0, 0.3);
    border-radius: 5px;
    margin: 15px 0;
    position: relative;
    box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
}

#missilePreview {
    width: 280px; 
    height: 200px;
    margin: 10px auto;
    position: relative; /* Ensure renderer gets properly placed */
}

#colorButtons {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    max-width: 350px;
    margin-bottom: 15px;
    gap: 6px; /* Use gap instead of margins for better spacing */
}

.color-button {
    width: 30px;
    height: 30px;
    border-radius: 5px;
    cursor: pointer;
    border: 2px solid #333;
    transition: transform 0.2s, border-color 0.2s;
    position: relative; /* Ensure position context for z-index */
    z-index: 10; /* Higher z-index to ensure clickability */
}

.color-button:hover {
    transform: scale(1.15);
    z-index: 20; /* Even higher when hovered */
}

.color-button.selected {
    border-color: #ffffff;
    box-shadow: 0 0 8px rgba(255, 255, 255, 0.8);
    z-index: 15; /* Higher than regular buttons but lower than hovered */
}
 
@media screen and (orientation: portrait) {
        #rotation-notice {
            display: flex !important;
        }
        #gameCanvas, #hud, #minimap, #leaderboard, #settingsBtn, #soundBtn, #micButton {
            opacity: 0;
            pointer-events: none;
        }
    }
    
    @media screen and (orientation: landscape) and (max-width: 926px) {
        /* Landscape phone optimization (iPhone 13 Pro Max width in landscape is 926px) */
        #hud {
            width: 35% !important;
            top: 10px !important;
            left: 10px !important;
            padding: 8px !important;
            font-size: 14px !important;
        }
        
        #minimap {
            width: 200px !important;
            height: 200px !important;
            bottom: 10px !important;
            left: 10px !important;
        }
        
        #leaderboard {
            width: 150px !important;
            padding: 10px !important;
            top: 10px !important;
            right: 10px !important;
            font-size: 12px !important;
        }
        
        #settingsBtn, #soundBtn, #micButton {
            width: 40px !important;
            height: 40px !important;
            font-size: 18px !important;
            bottom: 20px !important;
        }
        
        #controlsOverlay {
            font-size: 14px !important;
        }
    }
    
    /* Rotation notice styling */
    #rotation-notice {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.9);
        z-index: 10000;
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: white;
        font-family: 'Quantico', sans-serif;
        text-align: center;
        padding: 20px;
    }
    
    #rotation-notice img {
        width: 80px;
        height: 80px;
        margin-bottom: 20px;
        animation: rotate 2s infinite;
    }
    
    @keyframes rotate {
        0% { transform: rotate(0deg); }
        25% { transform: rotate(0deg); }
        75% { transform: rotate(-90deg); }
        100% { transform: rotate(-90deg); }
    }


    </style>

<script src="https://download.agora.io/sdk/release/AgoraRTC_N.js"></script>

</head>
<body>
    
    
        <!-- Add this at the beginning of the body -->
        <div id="rotation-notice">
            <svg width="120" height="120" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5">
                <path d="M21 12C21 7.03 16.97 3 12 3C7.03 3 3 7.03 3 12"></path>
                <path d="M12 15l-3-3m0 0l3-3m-3 3h12"></path>
            </svg>
            <h2 style="color:white; font-size:32px; margin:25px 0 15px 0;">PLEASE ROTATE YOUR DEVICE</h2>
            <p style="color:#cccccc; font-size:22px; margin-bottom:25px;">This game is designed for landscape mode</p>
            
            <button id="rotation-fullscreen-btn" 
                    style="margin-top:30px; 
                           background:#ff3333; 
                           color:white; 
                           border:none; 
                           padding:20px 30px; 
                           border-radius:10px; 
                           font-size:26px; 
                           font-weight:bold; 
                           cursor:pointer; 
                           box-shadow:0 0 20px rgba(255,51,51,0.8); 
                           width:280px; 
                           animation:pulse 1.5s infinite;">
                TAP FOR FULLSCREEN
            </button>
        </div>
    

    <div id="minimap"></div>
    <div id="hud"></div>

    <div id="gameOverScreen" style="display: none;">
        <div class="corner-decoration top-left"></div>
        <div class="corner-decoration top-right"></div>
        <div class="corner-decoration bottom-left"></div>
        <div class="corner-decoration bottom-right"></div>
        
        <h2>Mission Complete!</h2>
        <div id="gameOverStats"></div>
        <button id="restartButton" onclick="restartGame()">RELAUNCH!</button>
    </div>

    <div id="controlsOverlay">
        USE ARROW KEYS TO MANEUVER • SPACE TO ACCELERATE
    </div>

    <!-- Vibe Jam link  -->
    <a target="_blank" href="https://jam.pieter.com" style="font-family: 'system-ui', sans-serif; position: fixed; bottom: -1px; right: -1px; padding: 7px; font-size: 14px; font-weight: bold; background: #fff; color: #000; text-decoration: none; z-index: 10; border-top-left-radius: 12px; z-index: 10000; border: 1px solid #fff;">🕹️ Vibe Jam 2025</a>

    <!-- firebase  -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>

function requestFullscreen() {
    console.log("Fullscreen button clicked");
    try {
        // Visual feedback
        document.getElementById('rotation-fullscreen-btn').textContent = "ENTERING FULLSCREEN...";
        
        // Try standard method first
        if (document.documentElement.requestFullscreen) {
            document.documentElement.requestFullscreen();
        // Fall back to vendor prefixes
        } else if (document.documentElement.webkitRequestFullscreen) {
            document.documentElement.webkitRequestFullscreen();
        } else if (document.documentElement.msRequestFullscreen) {
            document.documentElement.msRequestFullscreen();
        } else if (document.body.webkitRequestFullscreen) {
            document.body.webkitRequestFullscreen();
        } else if (document.body.mozRequestFullScreen) {
            document.body.mozRequestFullScreen();
        }
        
        // Reset button text after a delay
        setTimeout(() => {
            document.getElementById('rotation-fullscreen-btn').textContent = "TAP FOR FULLSCREEN";
        }, 2000);
    } catch (e) {
        console.error("Fullscreen request failed:", e);
        document.getElementById('rotation-fullscreen-btn').textContent = "FULLSCREEN FAILED";
        
        setTimeout(() => {
            document.getElementById('rotation-fullscreen-btn').textContent = "TRY AGAIN";
        }, 2000);
    }
}

    document.addEventListener('DOMContentLoaded', function() {
    const fullscreenBtn = document.getElementById('rotation-fullscreen-btn');

    document.addEventListener('fullscreenchange', function() {
    console.log("Fullscreen state changed");
    checkOrientationAfterFullscreen();
});
    
    // Properly attach click event (instead of using inline onclick)
    if (fullscreenBtn) {
        fullscreenBtn.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            console.log("Fullscreen button clicked");
            fullscreenBtn.textContent = "ENTERING FULLSCREEN...";
            
            // Always request fullscreen on the document element, not the button
            try {
                // Request fullscreen on the DOCUMENT, not the button
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                } else if (document.documentElement.webkitRequestFullscreen) {
                    document.documentElement.webkitRequestFullscreen();
                } else if (document.documentElement.msRequestFullscreen) {
                    document.documentElement.msRequestFullscreen();
                } else {
                    console.warn("Fullscreen API not supported");
                }
                
                // Check orientation after a delay
                setTimeout(function() {
                    checkOrientationAfterFullscreen();
                }, 500);
            } catch (err) {
                console.error("Fullscreen error:", err);
                fullscreenBtn.textContent = "FULLSCREEN FAILED";
                
                setTimeout(() => {
                    fullscreenBtn.textContent = "TRY AGAIN";
                }, 2000);
            }
        });
    }
});

function checkOrientationAfterFullscreen() {
    // Force check orientation immediately after fullscreen
    handleOrientationChange();
    
    // Also check again after a longer delay to ensure everything updates
    setTimeout(() => {
        handleOrientationChange();
    }, 1000);
}


        // Game variables
        let scene, camera, renderer, missile, city;
        let buildings = [], targetBuildings = [];
        let gameActive = false;
        let startTime, elapsedTime = 0;
        let flightTimes = [], avgFlightTime = 0;
        let targetsDestroyed = 0, crashes = 0;
        let smokeParticles = [];
        let minimapCamera, minimapRenderer;
        let cameraOffset = new THREE.Vector3(0, 5, 15);
        let velocity = 0.6;
        let acceleration = 0.5;
        let maxVelocity = 6.0;
        let baseVelocity = 0.6;
        let isAccelerating = false;
        let turnSpeed = 0.05;
        let damping = 0.9;
        let turnVelocity = new THREE.Vector3(0, 0, 0);
        let missileDirection = new THREE.Vector3(0, 0, -1);
        let citySize = 400;
        let buildingCount = 200;
        let targetPercentage = 0.03;
        let explosionParticles = [];
        let spawnPoints = [
            new THREE.Vector3(0, 50, citySize * 2),    // North
            new THREE.Vector3(0, 50, -citySize * 2),   // South
            new THREE.Vector3(citySize * 2, 50, 0),    // East
            new THREE.Vector3(-citySize * 2, 50, 0)    // West
        ];
        let currentSpawnPoint;
        let screenShakeTime = 0;
        let screenShakeIntensity = 0;
        let clock = new THREE.Clock();
        let resetDelay = 0;
        let cameraTarget = null;
        let cameraUp = new THREE.Vector3(0, 1, 0); // Keep track of camera's up vector
        let prevCameraPosition = new THREE.Vector3();
        let prevMissileDirection = new THREE.Vector3(0, 0, -1);
        let launchAnimation = false;
        let launchAnimationTime = 0;
        const launchAnimationDuration = 2.0;
        let enemyMissiles = [];
        const maxEnemyMissiles = 5; // Maximum concurrent enemy missiles
        const enemyMissileSpawnRate = 3; // New enemy missile every 3 seconds
        let enemyMissileTimer = 0;
        let scorchMarks = [];
        let playerMarker; // For minimap visibility
        let animationFrameId; // For smoother animation
        let lastTime = 0; // For frame timing
        let minimapBuildingDots = [];
        let smoothedCameraPosition = new THREE.Vector3();
        let smoothedCameraLookAt = new THREE.Vector3();
        const cameraSmoothingFactor = 0.08; // Lower = smoother but slower
        let initialMissileAngle = 0;
        let minimapContainer;
        let minimapFixedRotation = 0;
        let exhaustGlow = null;
        let globalScorchTimer = null;
        let globalScorchInterval = 100; // milliseconds
        let scorchCleanupCounter = 0;
        let damagedBuildings = [];
        let entryPortal = null;
        let entryPortalRef = null;
        let db;
        let leaderboardListener = null;
        let lastFirebaseSync = 0;
        const FIREBASE_SYNC_INTERVAL = 10; // Sync every 10 seconds
        let smokeTimer = 0;
        let gameEndCheckTimer = 0;
        let playerSmokeTimer = 0;
        const GAME_END_CHECK_INTERVAL = 2.0;
        const obstacleCheckDistance = 50;
        const pathfindingUpdateRate = 0.2;
        let otherPlayers = {};
        let lastPositionUpdate = 0;
        const POSITION_UPDATE_INTERVAL = 100; // ms
        let rtcClient = null;
        let localAudioTrack = null;
        let isAudioEnabled = false;
        let joinedChannel = false;
        const enemyMissileMaxSpeed = 1.0; 
        const enemyMissileMinSpeed = 0.7;

        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        const MAX_SMOKE_PARTICLES = isMobile ? 3000 : 10000; 
        const MAX_EXPLOSION_PARTICLES = isMobile ? 5000 : 20000;

        const tempVector1 = new THREE.Vector3();
        const tempVector2 = new THREE.Vector3();
        const tempVec3 = new THREE.Vector3();
        const tempVec4 = new THREE.Vector3();
        const tempVec5 = new THREE.Vector3();
        const tempQuat = new THREE.Quaternion();
        const reusableBox = new THREE.Box3();
        const reusableVec1 = new THREE.Vector3();
        const reusableVec2 = new THREE.Vector3();
        
    
    const cameraShakeOffset = new THREE.Vector3();
    const missileBackVector = new THREE.Vector3();

    let globalSmokeTimer = 0;
    const globalSmokeInterval = 0.2; // How often to check for smoke emission (seconds)
    const globalSmokeChance = 0.7; // Base probability for emitting smoke
    let globalWindDirection = new THREE.Vector3(0.3, 0, 0.2); // Shared wind direction

    const gameTimers = {
    leaderboard: 0,       // Time since last leaderboard update
    firebaseSync: 0,      // Time since last Firebase sync
    enemyPilotStats: 0,   // Time since last enemy pilot stats update
    scorchCleanup: 0,     // Frames since last scorch cleanup
    effects: 0            // Time since last visual effects update
};
   
    const sounds = {
    explosion: null,
    missile: null,
    target: null,
    crash: null,
    flight1: null,
    flight2: null,
    ui: null,
    muted: true
    };

    const explosionMaterialPool = {
    yellow: null,
    orange: null, 
    red: null
    };

    const enemyExplosionMaterialPool = {
    yellow: null,
    orange: null,
    red: null
};

let enemyPilotStats = [
    { id: "cpu_1", name: "Marksman42", targetsDestroyed: 0, crashes: 0, totalPlayTimeSeconds: 60, tpm: 0 },
    { id: "cpu_2", name: "SkyStalker", targetsDestroyed: 0, crashes: 0, totalPlayTimeSeconds: 90, tpm: 0 },
    { id: "cpu_3", name: "MissileWizard", targetsDestroyed: 0, crashes: 0, totalPlayTimeSeconds: 75, tpm: 0 },
    { id: "cpu_4", name: "StrikeForce", targetsDestroyed: 0, crashes: 0, totalPlayTimeSeconds: 120, tpm: 0 },
    { id: "cpu_5", name: "TargetLocked", targetsDestroyed: 0, crashes: 0, totalPlayTimeSeconds: 85, tpm: 0 }
];
        
const portalConfig = {
    next: "https://portal.pieter.com",  // Where "Next" portals go
    self: "https://vibe-missile.vercel.app",// "Back" portals go to ref parameter
    transitionDuration: 1000           // Transition animation time in ms
};

        // Input state
        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            Space: false,
            KeyW: false,
            KeyS: false
        };

        // Game stats
        const stats = {
            targetsRemaining: 0,
            targetsDestroyed: 0,
            crashes: 0,
            flightTime: 0
        };

    // Player tracking for multiplayer
    let playerStats = {
    id: generatePlayerId(),
    name: "You", 
    targetsDestroyed: 0,
    crashes: 0,
    roundsWon: 0,
    color: "#5c5c5c", // Default color
};

// Leaderboard tracking
let leaderboard = [
    // Will be populated with player data
];    

const firebaseConfig = {
    apiKey: "AIzaSyAKNrmt5HLrxYjEukNH85e01-eyAsUGvf4",
    authDomain: "vibe-missile.firebaseapp.com",
    projectId: "vibe-missile",
    databaseURL: "https://vibe-missile-default-rtdb.firebaseio.com",
    storageBucket: "vibe-missile.appspot.com",
    messagingSenderId: "1048243867578",
    appId: "1:1048243867578:web:9c502d5275fcb8a43b5783"
};

// Initialize Agora client
async function initializeAgoraVoiceChat() {
    const AGORA_APP_ID = "YOUR_AGORA_APP_ID"; // Replace with your App ID
    
    try {
        // Check if Agora is available
        if (!window.AgoraRTC) {
            console.error("Agora RTC SDK not loaded. Make sure to include the script in your HTML.");
            return;
        }
        
        // Create an Agora client
        rtcClient = AgoraRTC.createClient({ mode: "rtc", codec: "vp8" });
        console.log("Agora client initialized successfully");
    } catch (error) {
        console.error("Failed to initialize Agora client:", error);
    }
}

async function joinAgoraChannel() {
    if (!rtcClient) {
        console.error("Agora client not initialized");
        return;
    }
    
    if (joinedChannel) {
        console.log("Already joined channel");
        return;
    }
    
    try {
        // Use player's unique ID as their Agora UID
        const uid = playerStats.id;
        const channelName = "missile_sim_main_channel";
        const token = null; // Use null for testing with App ID auth
        
        console.log("Attempting to join channel:", channelName);
        
        // DON'T create microphone track yet, just join the channel
        await rtcClient.join(AGORA_APP_ID, channelName, token, uid);
        console.log("Joined Agora channel:", channelName);
        
        // Create a dummy track that just handles UI state
        localAudioTrack = { 
            setEnabled: function(enabled) {
                console.log("Audio state updated:", enabled);
                isAudioEnabled = enabled;
                updateVoiceChatUI();
                
                // If user is enabling audio, create the real track now
                if (enabled && !this.isRealTrack) {
                    createRealAudioTrack();
                }
            },
            isRealTrack: false
        };
        
        // Initialize as muted
        isAudioEnabled = false;
        
        joinedChannel = true;
        updateVoiceChatUI();
    } catch (error) {
        console.error("Error joining Agora channel:", error);
        
        // Create dummy implementations to prevent UI errors
        localAudioTrack = { 
            setEnabled: function(enabled) { 
                console.log("Dummy mic set to:", enabled);
                isAudioEnabled = enabled;
                updateVoiceChatUI();
                
                // If user is enabling audio, create the real track
                if (enabled && !this.isRealTrack) {
                    createRealAudioTrack();
                }
            },
            isRealTrack: false
        };
        
        joinedChannel = true; // Mark as joined so UI works
        updateVoiceChatUI();
    }
}

async function createRealAudioTrack() {
    try {
        // Now we request microphone permission
        const micTrack = await AgoraRTC.createMicrophoneAudioTrack();
        console.log("Microphone track created successfully");
        
        // Replace the dummy track with the real one
        const wasEnabled = isAudioEnabled;
        localAudioTrack = micTrack;
        localAudioTrack.isRealTrack = true;
        
        // Publish the track
        await rtcClient.publish([micTrack]);
        console.log("Published local audio track");
        
        // Apply the previous state
        localAudioTrack.setEnabled(wasEnabled);
        
    } catch (error) {
        console.error("Failed to create microphone track:", error);
        alert("Microphone access denied. Please allow microphone access to use voice chat.");
        
        // Reset audio state since permission was denied
        isAudioEnabled = false;
        updateVoiceChatUI();
    }
}

// Generate a unique player ID
function generatePlayerId() {
    return 'player_' + Math.random().toString(36).substr(2, 9);
}

    // Preload sound effects
    function initSounds() {
    // Load all sound effects
    sounds.explosion = new Audio('explosion.mp3');
    sounds.missile = new Audio('missile.mp3');
    sounds.missile2 = new Audio('missile2.mp3');
    sounds.target = new Audio('target.mp3');
    sounds.crash = new Audio('crash.mp3');
    sounds.ui = new Audio('ui.mp3');
    sounds.flight1 = new Audio('flight1.mp3');
    sounds.flight1.loop = true;  
    sounds.flight1.volume = 0.4;
    sounds.flight2 = new Audio('flight2.mp3');
    sounds.flight2.loop = true;  
    sounds.flight2.volume = 0.5;
    
    // Set all to low volume initially
    Object.values(sounds).forEach(sound => {
        if (sound && sound.volume) sound.volume = 0.5;
    });
   
}

// Play sound with error handling
function playSound(soundName) {
    if (sounds.muted) return;
    
    const sound = sounds[soundName];
    if (!sound) return;
    
    // Reset sound to beginning if it's still playing
    sound.pause();
    sound.currentTime = 0;
    
    // Play the sound with a catch for autoplay restrictions
    const playPromise = sound.play();
    if (playPromise !== undefined) {
        playPromise.catch(error => {
            console.log("Audio play prevented by browser:", error);
        });
    }
}

function startFlightSound() {
    if (sounds.muted) return;
    
    // Start with normal flight sound
    sounds.flight1.currentTime = 0;
    sounds.flight1.play().catch(e => console.log("Couldn't play flight sound:", e));
    sounds.currentLoop = "flight1";
}

function stopFlightSounds() {
    // Stop all flight sounds
    sounds.flight1.pause();
    sounds.flight1.currentTime = 0;
    sounds.flight2.pause();
    sounds.flight2.currentTime = 0;
    sounds.currentLoop = null;
}

function updateFlightSound(isAccelerating) {
    if (sounds.muted) return;
    
    if (!window.flightSoundPool) {
        initFlightSoundPool();
    }
    
    // Choose appropriate sound pool
    const soundType = isAccelerating ? 'flight2' : 'flight1';
    
    // If we're already playing the right type, continue
    if (sounds.currentLoop === soundType) return;
    
    // Get next sound from the appropriate pool
    window.currentFlightIndex = (window.currentFlightIndex + 1) % window.flightSoundPool[soundType].length;
    const nextSound = window.flightSoundPool[soundType][window.currentFlightIndex];
    
    // Cross-fade (start new sound before stopping old)
    nextSound.currentTime = 0;
    nextSound.play().catch(e => {});
    
    // Stop other sounds after a short delay
    setTimeout(() => {
        if (soundType === 'flight1') {
            window.flightSoundPool.flight2.forEach(s => { s.pause(); s.currentTime = 0; });
        } else {
            window.flightSoundPool.flight1.forEach(s => { s.pause(); s.currentTime = 0; });
        }
    }, 50);
    
    sounds.currentLoop = soundType;
}

// Toggle mute state
function toggleMute() {
    sounds.muted = !sounds.muted;
    
    if (sounds.muted) {
        stopFlightSounds();
    } else if (gameActive && missile.visible && !launchAnimation && resetDelay <= 0) {
        // Resume the appropriate flight sound
        updateFlightSound(isAccelerating);
    }
}

// Track selected missile color
let selectedMissileColor = "#ff3333"; // Default red color

// Initialize color picker
function initColorPicker() {
    const colors = [
        // Reds
        // Reds
        "#ff0000", "#ff3333", "#ff6666", "#cc0000", 
        // Oranges/Yellows
        "#ff8800", "#ffaa00", "#ffcc00", "#ffff00", 
        // Greens
        "#00cc00", "#00ff00", "#33ff33", 
        // Blues
        "#0000ff", "#3333ff", "#0099ff", 
        // Purples (expanded selection)
        "#6600cc", "#9900ff", "#cc00ff", "#8800cc", "#aa00ee",
        // Pinks (new section)
        "#ff00ff", "#ff66ff", "#ff99ff", "#ff3399", "#cc0099",
        // Grayscale/Special
        "#ffffff", "#aaaaaa", "#000000", "#00ffff"
    ];
    
    const colorButtonsContainer = document.getElementById('colorButtons');
    colorButtonsContainer.innerHTML = ''; // Clear any existing buttons

    // Create color buttons
    colors.forEach((color) => {
        const button = document.createElement('div');
        button.className = 'color-button';
        button.style.backgroundColor = color;
        
        // Select button if it's the default color
        if (color === selectedMissileColor) {
            button.classList.add('selected');
        }
        
         // Use more reliable click event instead of mousedown
          button.addEventListener('click', function(e) {
            e.stopPropagation(); // Stop event bubbling
            
            // Remove selection from all buttons
            document.querySelectorAll('.color-button').forEach(btn => {
                btn.classList.remove('selected');
            });
            
            // Add selection to clicked button
            this.classList.add('selected');
            
            // Update selected color
            selectedMissileColor = color;
            
            // Update missile preview
           // updateMissilePreviewColor(color); // skip update missile preview
        });

        // Also handle touch events for mobile
        button.addEventListener('touchstart', function(e) {
            e.preventDefault();
            e.stopPropagation();
            // Same logic as mousedown
            document.querySelectorAll('.color-button').forEach(btn => {
                btn.classList.remove('selected');
            });
            this.classList.add('selected');
            selectedMissileColor = color;
          //   updateMissilePreviewColor(color);  /skip update missile preview
        }, {passive: false});

        colorButtonsContainer.appendChild(button);
    });
    
    // Set up 3D missile preview
   
}






// Show and hide controls overlay
function showControlsOverlay() {
    // Only show if this is the first time (check if we've shown it before)
    if (window.controlsShown) return;
    window.controlsShown = true;
    
    const overlay = document.getElementById('controlsOverlay');
    
    // Show device-appropriate controls
    if (isMobile) {
        overlay.innerHTML = 'TILT DEVICE TO STEER • TAP SCREEN TO ACCELERATE';
    } else {
        overlay.innerHTML = 'USE ARROW KEYS TO MANEUVER • SPACE TO ACCELERATE';
    }
    
    overlay.style.opacity = "1";
    
    // Hide after 4 seconds and never show again
    setTimeout(() => {
        hideControlsOverlay();
    }, 4000);
}

function hideControlsOverlay() {
    const overlay = document.getElementById('controlsOverlay');
    if (overlay) {
        overlay.style.opacity = "0";
    }
}


// initialize mobile controls
function initMobileControls() {
    if (!isMobile) return;
    
    // Clear any existing touch listeners
    renderer.domElement.removeEventListener('touchstart', handleTouchStart);
    renderer.domElement.removeEventListener('touchend', handleTouchEnd);
    
    // Add tap event listener to toggle acceleration
    renderer.domElement.addEventListener('touchstart', handleTouchStart, { passive: false });
    renderer.domElement.addEventListener('touchend', handleTouchEnd, { passive: false });
    
    // Show mobile instructions
    document.getElementById('controlsOverlay').innerHTML = 
        'TILT DEVICE TO STEER • TAP SCREEN TO ACCELERATE';
    document.getElementById('controlsOverlay').style.opacity = "1";
    setTimeout(() => {
        document.getElementById('controlsOverlay').style.opacity = "0";
    }, 5000);
}

function handleTouchStart(e) {
    e.preventDefault();
    isAccelerating = true;
    updateFlightSound(true);
}

function handleTouchEnd(e) {
    e.preventDefault();
    isAccelerating = false;
    updateFlightSound(false);
}

 // Initialize the game
 init();

 // 1. Remove the startMenu display toggle in init()
function init() {
    // Initialize sounds
    initSounds();
    initSoundPool();
    initFirebase(); 
     // Create debug window
    initializeSettingsPanel();

    // optimize for mobile
    if (isMobile) {
        optimizeForMobile();
        handleOrientationChange(); // Initial check
        console.log("Mobile optimizations applied");
    }

    // Set up the scene
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);  // Sky blue
    scene.fog = new THREE.FogExp2(0x87CEEB, 0.0015);

    THREE.Object3D.DefaultUp.set(0, 1, 0);

    // Set up the renderer
    renderer = new THREE.WebGLRenderer({ 
        antialias: true,
        powerPreference: "high-performance", // Request high-performance GPU
        precision: "mediump" // Use medium precision shaders on mobile
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = false;
    renderer.sortObjects = false;
    document.body.appendChild(renderer.domElement);

    // Add lights
    const ambientLight = new THREE.AmbientLight(0x404040, 1);
    scene.add(ambientLight);

    // Improve directional light for better shadows
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(200, 300, 100);
    directionalLight.castShadow = false;
    
    // Increase shadow map size for more detailed shadows
    directionalLight.shadow.mapSize.width = 1024;
    directionalLight.shadow.mapSize.height = 1024;
    
    // Add shadow bias to reduce shadow acne
    directionalLight.shadow.bias = -0.001;

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
    
    // Initialize camera reference frame IMMEDIATELY after creating the camera
    camera.userData = {
        verticalReferenceFrame: {
            forward: new THREE.Vector3(0, 0, -1),
            right: new THREE.Vector3(1, 0, 0),
            up: new THREE.Vector3(0, 1, 0)
        }
    };
    
    // Define smoothedCameraPosition and smoothedCameraLookAt
    smoothedCameraPosition = new THREE.Vector3();
    smoothedCameraLookAt = new THREE.Vector3();

     // Safely initialize camera references
     ensureCameraReferences();

    
    scene.add(directionalLight);

    initializeEnemyPilots(); // Initialize enemy pilots

    // Create the terrain
    createTerrain();
       
    // Create the city
    createCity();

    createPortalRings(); // Create portal rings
    
    // Set up the minimap
    setupMinimap();

    createLeaderboard(); // Create leaderboard
    setTimeout(updateLeaderboard, 500); // Force update soon after start
 
    // Create the missile
    createMissile();

    initExplosionTextures(); // Initialize explosion textures once
    initEnemyExplosionMaterials(); // Initialize enemy explosion materials
    
    // Event listeners
    window.addEventListener('resize', onWindowResize);
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);

    enhancePlayerInitialization() // Initialize player stats
    
    // Mobile device orientation controls
    if (window.DeviceOrientationEvent) {
        window.addEventListener('deviceorientation', handleDeviceOrientation);
    }

    if (isMobile) {
        optimizeForMobile();
        
        // Replace standard control instructions
        if (document.getElementById('controlsOverlay')) {
            document.getElementById('controlsOverlay').innerHTML = 
                'TILT DEVICE TO STEER • TAP SCREEN TO ACCELERATE';
        }
        
        // Set up mobile-specific game properties
        baseVelocity = 0.5; // Slower base speed for easier control
        turnSpeed *= 0.8; // Gentler turns
        damping = 0.8; // More damping for smoother controls
        
        // Disable or simplify heavy effects
        MAX_SMOKE_PARTICLES = 2000;
        MAX_EXPLOSION_PARTICLES = 5000;
    }
    
     // Initialize Agora voice chat
     initializeAgoraVoiceChat();
    
    // Create voice chat UI
    createVoiceChatUI();
    
    
    
    // Initialize game directly - no start menu
    document.getElementById('hud').style.display = 'block';
    document.getElementById('minimap').style.display = 'block';
    createHudElements();
    gameActive = true;
    resetMissile();
    
    // Skip launch animation
    launchAnimation = false;
    velocity = baseVelocity;
    
    // Set up camera position immediately
    const cameraPos = missile.position.clone().sub(
        missileDirection.clone().multiplyScalar(cameraOffset.z)
    );
    cameraPos.y += cameraOffset.y;
    camera.position.copy(cameraPos);
    camera.lookAt(missile.position);
    smoothedCameraPosition.copy(camera.position);
    smoothedCameraLookAt.copy(missile.position);
    
    // Show controls briefly to inform player
    document.getElementById('controlsOverlay').innerHTML = 'USE ARROW KEYS TO MANEUVER • SPACE TO ACCELERATE';
    showControlsOverlay();
    
    // Start sounds
    playSound('missile');
    startFlightSound();

    renderer.domElement.addEventListener('webglcontextlost', function(event) {
        event.preventDefault();
        console.error('WebGL context lost. Attempting recovery...');
       
        // Clean up resources to help recovery
        for (let i = smokeParticles.length - 1; i >= 0; i--) {
            disposeObject(smokeParticles[i]);
        }
        smokeParticles = [];
        
        for (let i = explosionParticles.length - 1; i >= 0; i--) {
            disposeObject(explosionParticles[i]);
        }
        explosionParticles = [];
        
        // Alert user
        alert("Graphics context lost. Try refreshing the page.");
    }, false);

    renderer.domElement.addEventListener('webglcontextrestored', function() {
        console.log('WebGL context restored!');
        lastTime = 0;
        requestAnimationFrame(animate);
    }, false);

    initPortals(); // Initialize portals

    addDummyPlayers(); // Add dummy players for testing

    createSoundButton(); // Create sound button

    // Start animation loop
    lastTime = 0; // Reset lastTime
    requestAnimationFrame(animate);
}    

function initPortals() {
    // Handle incoming portal parameters
    handleIncomingPortal();
    
    // Update materials for portal animation
    updatePortalMaterials();
}

function setupMultiplayerSync() {
    // Skip if already initialized
    if (window.multiplayerSyncInitialized) return;
    
    console.log("Setting up multiplayer sync with players collection only");
    
    if (!db || !firebase.auth().currentUser) return;
    
    // Use ONLY players collection
    const playersCollection = db.collection("players");
    const playerId = playerStats.id;
    const playerRef = playersCollection.doc(playerId);
    
    // Initial player data
    const playerData = {
        name: playerStats.name,
        color: playerStats.color,
        position: { 
            x: missile.position.x, 
            y: missile.position.y, 
            z: missile.position.z 
        },
        direction: { 
            x: missileDirection.x, 
            y: missileDirection.y, 
            z: missileDirection.z 
        },
        lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
        isActive: true,
        isAccelerating: false
    };
    
    // Create or update player entry
    playerRef.set(playerData, { merge: true })
        .then(() => {
            setupPlayerPresence(playerRef);
            startPositionSync(playerRef);
            window.multiplayerSyncInitialized = true;
        })
        .catch(error => {
            console.error("Error joining multiplayer:", error);
        });
    
    // Listen for other players
    listenForOtherPlayers(playersCollection);
}

// New function to clean up stale Firebase player entries
function cleanupStaleFirebasePlayers() {
    if (!db || !firebase.auth().currentUser) {
        console.log("Firebase not available, skipping stale player cleanup");
        return;
    }
    
    // Get reference to active players
    const playersCollection = db.collection("players");
    
    // Set threshold for stale entries (e.g., 5 minutes ago)
    const staleThreshold = new Date();
    staleThreshold.setMinutes(staleThreshold.getMinutes() - 5);
    
    // Find and delete stale entries
    playersCollection.where("lastUpdated", "<", staleThreshold)
        .get()
        .then((snapshot) => {
            if (snapshot.empty) {
                console.log("No stale player entries found");
                return;
            }
            
            console.log(`Found ${snapshot.size} stale player entries to clean up`);
            
            // Batch delete all stale entries
            const batch = db.batch();
            snapshot.forEach((doc) => {
                console.log(`Cleaning up stale player: ${doc.id}`);
                batch.delete(doc.ref);
            });
            
            // Commit the batch delete
            return batch.commit();
        })
        .then(() => {
            console.log("Stale player cleanup complete");
        })
        .catch((error) => {
            console.error("Error cleaning up stale players:", error);
        });
}

//firebase powerwash
function cleanupAllOtherPlayerMissiles() {
    console.log("Cleaning up all other player missiles");
    
    // Make a copy of keys to avoid modification during iteration
    const playerIds = Object.keys(otherPlayers);
    
    // Clear each player's missile
    playerIds.forEach(playerId => {
        removeOtherPlayer(playerId);
    });
    
    // Clear the otherPlayers object completely to ensure fresh start
    otherPlayers = {};
    
    // Update UI
    updatePlayerCountUI();
    updateLeaderboard();
    
    // Also remove any stale entries from Firebase
    cleanupStaleFirebasePlayers();
}

function handleOrientationChange() {
    // Check if device is in portrait mode
    const isPortrait = window.innerHeight > window.innerWidth;
    const rotationNotice = document.getElementById('rotation-notice');

    if (rotationNotice) {
        if (isPortrait && !document.fullscreenElement) {
            // Only show rotation notice in portrait mode AND not in fullscreen
            rotationNotice.style.display = 'flex';
            
            // Game elements should be hidden
            document.getElementById('gameCanvas').style.opacity = '0';
            document.getElementById('hud').style.opacity = '0';
            document.getElementById('minimap').style.opacity = '0';
            document.getElementById('leaderboard').style.opacity = '0';
        } else {
            // In landscape OR fullscreen, hide rotation notice
            rotationNotice.style.display = 'none';
            
            // Game elements should be visible
            document.getElementById('gameCanvas').style.opacity = '1';
            document.getElementById('hud').style.opacity = '1';
            document.getElementById('minimap').style.opacity = '1';
            document.getElementById('leaderboard').style.opacity = '1';
            
            // Force a rerender to fix any layout issues
            setTimeout(() => {
                onWindowResize();
            }, 300);
        }
    }
}

// Make sure the rotation notice has appropriate z-index and fully visible content
const rotationNoticeStyle = document.createElement('style');
rotationNoticeStyle.textContent = `
    #rotation-notice {
        z-index: 99999;
        background-color: rgba(0,0,0,0.95);
    }
    #rotation-notice * {
        opacity: 1 !important;
        visibility: visible !important;
    }
    #rotation-fullscreen-btn {
        transform: scale(1.1);
        transition: transform 0.2s;
    }
    #rotation-fullscreen-btn:active {
        transform: scale(0.95);
    }
`;
document.head.appendChild(rotationNoticeStyle);


function optimizeForMobile() {
    if (!isMobile) return;
    
    console.log("Optimizing for mobile with landscape orientation");
    
    // Add orientation change handling
    window.addEventListener('orientationchange', function() {
        setTimeout(() => {
            handleOrientationChange();
            scaleMobileUI(); // Scale UI after orientation change
        }, 300); // Small delay to allow rotation to complete
    });
    
    // Also check on resize for browsers that don't support orientationchange
    window.addEventListener('resize', function() {
        handleOrientationChange();
        scaleMobileUI(); // Scale UI on resize
    });
    
    // Initial check
    handleOrientationChange();
    
    // Try to force landscape if possible
    if (screen.orientation && screen.orientation.lock) {
        screen.orientation.lock('landscape').catch(e => {
            console.log("Could not lock to landscape:", e);
        });
    }
    
    console.log("Optimizing for mobile with desktop rendering");
    
    // 1. Set viewport for desktop-style rendering but keep mobile detection
    let viewportMeta = document.querySelector('meta[name="viewport"]');
    if (!viewportMeta) {
        viewportMeta = document.createElement('meta');
        viewportMeta.name = 'viewport';
        document.head.appendChild(viewportMeta);
    }
    viewportMeta.content = 'width=1280, initial-scale=1.0, maximum-scale=1.0, user-scalable=no';
    
    // 2. Add fullscreen button
    const fullscreenBtn = document.createElement('button');
    fullscreenBtn.id = 'fullscreenBtn';
    fullscreenBtn.innerHTML = '⛶ Full';
    fullscreenBtn.style.position = 'absolute';
    fullscreenBtn.style.bottom = '120px';
    fullscreenBtn.style.right = '20px';
    fullscreenBtn.style.padding = '8px 12px';
    fullscreenBtn.style.background = 'rgba(0,0,0,0.5)';
    fullscreenBtn.style.color = 'white';
    fullscreenBtn.style.border = 'none';
    fullscreenBtn.style.borderRadius = '5px';
    fullscreenBtn.style.zIndex = '10000';
    fullscreenBtn.style.fontSize = '16px';
    
    fullscreenBtn.addEventListener('click', () => {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(e => {
                console.error('Fullscreen error:', e);
            });
            fullscreenBtn.innerHTML = '✕ Exit';
            
            // Apply UI scaling after going fullscreen
            setTimeout(scaleMobileUI, 300);
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
                fullscreenBtn.innerHTML = '⛶ Full';
            }
        }
    });
    document.body.appendChild(fullscreenBtn);

    // Add enhanced mobile controls
    enhanceMobileControls();
    
    // 3. Ensure touch controls work properly
    renderer.domElement.addEventListener('touchstart', handleTouchStart, { passive: false });
    renderer.domElement.addEventListener('touchend', handleTouchEnd, { passive: false });
    
    // 4. Show mobile-specific instructions
    setTimeout(() => {
        const controlsOverlay = document.getElementById('controlsOverlay');
        if (controlsOverlay) {
            controlsOverlay.innerHTML = 'TILT DEVICE TO STEER • TAP SCREEN TO ACCELERATE';
            controlsOverlay.style.opacity = '1';
            
            setTimeout(() => {
                controlsOverlay.style.opacity = '0';
            }, 5000);
        }
    }, 1000);

     // 5. Add global mobile UI scaling
     addMobileUIStyles();
    
    // 6. Apply initial scaling
    scaleMobileUI();
    
    // Add fullscreen change listener
    document.addEventListener('fullscreenchange', scaleMobileUI);
}

function addMobileUIStyles() {
    // Create or update global mobile UI styles
    let mobileStyles = document.getElementById('mobile-ui-styles');
    if (!mobileStyles) {
        mobileStyles = document.createElement('style');
        mobileStyles.id = 'mobile-ui-styles';
        document.head.appendChild(mobileStyles);
    }
    
    // Set up the base styles
    mobileStyles.textContent = `
        /* Global UI scaling */
        #hud, #leaderboard, #minimap, #settingsBtn, #soundBtn, #micButton, 
        #voice-chat-container, #settingsPanel, #player-counter {
            transform-origin: bottom right;
            transition: transform 0.3s ease-out, opacity 0.3s ease-out;
        }
        
        /* Apply landscape mobile optimization */
        @media (max-width: 1024px) and (orientation: landscape) {
            #leaderboard {
                width: 180px !important;
                right: 10px !important;
                top: 10px !important;
                opacity: 0.85;
                font-size: 12px !important;
            }
            
            #hud {
                width: 280px !important;
                opacity: 0.85;
                font-size: 14px !important;
            }
            
            #minimap {
                width: 180px !important;
                height: 180px !important;
                left: 10px !important;
                bottom: 10px !important;
                opacity: 0.85;
            }
            
            #settingsBtn, #soundBtn, #micButton {
                width: 40px !important;
                height: 40px !important;
                font-size: 18px !important;
            }
            
            /* Adjust spacing between buttons */
            #settingsBtn { right: 20px !important; }
            #soundBtn { right: 70px !important; }
            #micButton { right: 120px !important; }
            
            /* Settings panel positioning */
            #settingsPanel {
                max-height: 70vh;
                width: 250px !important;
                overflow-y: auto;
            }
        }
    `;
}

function scaleMobileUI() {
    if (!isMobile) return;
    
    // Get screen dimensions and orientation
    const width = window.innerWidth;
    const height = window.innerHeight;
    const isLandscape = width > height;
    
    // Skip if not in landscape mode
    if (!isLandscape) return;
    
    // Calculate scale factor based on screen height
    const baseHeight = 800; // Base design height
    const scale = Math.min(1.0, height / baseHeight);
    
    // Apply scale to UI elements
    const elements = {
        hud: document.getElementById('hud'),
        leaderboard: document.getElementById('leaderboard'),
        minimap: document.getElementById('minimap'),
        settingsBtn: document.getElementById('settingsBtn'),
        soundBtn: document.getElementById('soundBtn'),
        playerCounter: document.getElementById('player-counter')
    };
    
    // Apply scale to each element if it exists
    Object.values(elements).forEach(el => {
        if (el) {
            el.style.transform = `scale(${scale})`;
            
            // Special positioning for certain elements
            if (el.id === 'minimap') {
                // Keep minimap in corner by adjusting for scale
                const offset = (1 - scale) * 50;
                el.style.marginLeft = `${offset}px`;
                el.style.marginBottom = `${offset}px`;
            }
        }
    });
    
    // Apply scale to any other UI elements that might need it
    const otherElements = document.querySelectorAll('.ui-element');
    otherElements.forEach(el => {
        el.style.transform = `scale(${scale})`;
    });
    
    console.log(`Applied mobile UI scaling: ${scale.toFixed(2)} for ${width}x${height}`);
}


function enhancePlayerInitialization() {
  // NATO phonetic alphabet names
  const natoNames = [
    "Alpha", "Bravo", "Charlie", "Delta", "Echo", 
    "Foxtrot", "Golf", "Hotel", "India", "Juliet", 
    "Kilo", "Lima", "Mike", "November", "Oscar", 
    "Papa", "Quebec", "Romeo", "Sierra", "Tango", 
    "Uniform", "Victor", "Whiskey", "X-ray", "Yankee", "Zulu"
  ];
  
  // Check if player came through portal (already has a name)
  if (!playerStats.name || playerStats.name === "You") {
    // Get random name from NATO phonetic alphabet
    const randomNameIndex = Math.floor(Math.random() * natoNames.length);
    const randomNumber = Math.floor(Math.random() * 99) + 1;
    playerStats.name = `${natoNames[randomNameIndex]}-${randomNumber}`;
  }
  
  // Randomize missile color if not already set
  if (!playerStats.color || playerStats.color === "#5c5c5c") {
    // Generate a visually distinct random color
    const hue = Math.floor(Math.random() * 360);
    const saturation = Math.floor(Math.random() * 30) + 70; // 70-100%
    const lightness = Math.floor(Math.random() * 20) + 40;  // 40-60%
    playerStats.color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    
    // Apply the color to player's missile
    if (missile && missile.children && missile.children[0]) {
      missile.children[0].material.color.set(playerStats.color);
    }
    updatePlayerMarkerColor();

  }
  
  // Make sure firebase ID is set
  playerStats.id = playerStats.id || generatePlayerId();
  
  console.log(`Player initialized: ${playerStats.name} with color ${playerStats.color}`);
}





function initializeGameState() {
    console.log("Performing complete game state initialization");
    
    // 1. COMPLETELY CLEAR all Firebase player data to remove "Human X" entries
    if (window.firestore) {
        // Get reference to players collection
        const playersRef = window.firestore.collection('players');
        
        // Query for "Human" prefixed names
        playersRef.where('name', '>=', 'Human')
                 .where('name', '<=', 'Human\uf8ff')
                 .get()
                 .then((snapshot) => {
                     // Delete each "Human X" document
                     snapshot.forEach((doc) => {
                         console.log("Removing stale player:", doc.data().name);
                         doc.ref.delete();
                     });
                 })
                 .catch(error => {
                     console.error("Error cleaning up stale players:", error);
                 });
    }
    
    // 2. Clear local leaderboard
    leaderboard = [];
    
    // 3. Initialize enemy pilots with NATO names only
    syncEnemyPilotsWithFirebase();
    
    // 4. Add current player to leaderboard
    leaderboard.push({
        id: playerStats.id,
        name: playerStats.name,
        targetsDestroyed: playerStats.targetsDestroyed,
        tpm: playerStats.tpm || 0,
        color: playerStats.color || "#ffffff"
    });
    
    // 5. Add enemy pilots to leaderboard
    enemyPilotStats.forEach(pilot => {
        leaderboard.push({
            id: pilot.id,
            name: pilot.name,
            targetsDestroyed: pilot.targetsDestroyed || 0,
            tpm: pilot.tpm || 0,
            color: pilot.color || "#66ccff",
            isEnemyPilot: true
        });
    });
    
    // 6. Log the clean leaderboard for debugging
    console.log("Clean leaderboard initialized:", 
                leaderboard.map(p => `${p.name}: ${p.targetsDestroyed} kills`));
    
    // 7. Update UI
    updateLeaderboard();
}

function startPositionSync(playerRef) {
    console.log("Starting position sync with consolidated collection...");
    
    // Clear any existing interval to prevent duplicates
    if (window.positionSyncInterval) {
        clearInterval(window.positionSyncInterval);
        window.positionSyncInterval = null;
    }
    
    // Set up interval to update position data
    const syncInterval = setInterval(() => {
        // Only sync if game is active and missile exists
        if (!gameActive || !missile || !missile.visible) return;
        
        try {
            // Update player position in Firebase (now always in players collection)
            playerRef.update({
                position: {
                    x: missile.position.x,
                    y: missile.position.y,
                    z: missile.position.z
                },
                direction: {
                    x: missileDirection.x,
                    y: missileDirection.y,
                    z: missileDirection.z
                },
                isAccelerating: isAccelerating,
                isActive: true,
                lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
            }).catch(error => {
                console.error("Error updating position:", error);
            });
        } catch (error) {
            console.error("Error in position sync:", error);
        }
    }, 100); // Update 10 times per second
    
    window.positionSyncInterval = syncInterval;
}

function initFirebase() {
    console.log("Initializing Firebase...");
    
    try {
        // Initialize Firebase with configuration
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
        
        // Initialize Firestore
        window.firestore = firebase.firestore();
        db = window.firestore;
        
        // Initialize Realtime Database (for presence detection)
        window.firebaseDB = firebase.database();
        
        // Set up authentication
        firebase.auth().onAuthStateChanged(user => {
            if (user) {
                console.log("User signed in. ID:", user.uid);
                playerStats.firebaseId = user.uid;
                playerStats.id = user.uid;
                
                // Clean up Firebase players collection
                cleanupFirebasePlayersCollection()
                    .then(() => {
                        console.log("Firebase collection cleaned, initializing player...");
                        onPlayerAuthenticated();
                        fetchPlayerData(user.uid);
                        
                        // Only subscribe AFTER cleanup to avoid flash of wrong data
                        subscribeToLeaderboard();
                    })
                    .catch(error => {
                        console.error("Firebase cleanup error:", error);
                        onPlayerAuthenticated();
                        fetchPlayerData(user.uid);
                        subscribeToLeaderboard();
                    });
            } else {
                console.log("No authenticated user, signing in anonymously");
                firebase.auth().signInAnonymously().catch(error => {
                    console.error("Error signing in anonymously:", error);
                });
            }
        });
        
        console.log("Firebase initialization complete");
        return true;
    } catch (error) {
        console.error("Error initializing Firebase:", error);
        return false;
    }
}

function cleanupFirebasePlayersCollection() {
    console.log("Cleaning up players collection...");
    
    if (!window.firestore || !firebase.auth().currentUser) {
        console.error("Firebase not initialized or user not authenticated");
        return Promise.resolve();
    }
    
    // Use ONLY the players collection - remove all references to activePlayers
    const playersCollection = db.collection("players");
    
    return playersCollection.limit(10).get()
        .then(snapshot => {
            if (snapshot.empty) {
                return Promise.resolve();
            }
            
            const batch = db.batch();
            let batchSize = 0;
            
            snapshot.docs.forEach(doc => {
                if (doc.id !== playerStats.id) {
                    batch.delete(doc.ref);
                    batchSize++;
                }
            });
            
            if (batchSize > 0) {
                return batch.commit();
            }
            return Promise.resolve();
        });
}

// Fetch existing player data if they've played before
function fetchPlayerData(userId) {
    db.collection("players").doc(userId).get().then(doc => {
        if (doc.exists) {
            const data = doc.data();
            
            // MODIFIED: Only update name if we don't already have a custom name set
            // (NATO names or portal names should be preserved)
            if ((playerStats.name === "You" || !playerStats.name) && 
                !playerStats.name.includes("-")) {  // NATO names contain hyphens
                playerStats.name = data.name;
            }
            
            // Copy over persistent stats
            playerStats.allTimeTargetsDestroyed = data.allTimeTargetsDestroyed || 0;
            playerStats.totalPlayTimeSeconds = data.totalPlayTimeSeconds || 0;
            
            // MODIFIED: Only apply color from Firebase if we don't already have a valid color
            // (This prevents overriding the initial random color)
            if (data.color && (!playerStats.color || playerStats.color === "#5c5c5c")) {
                playerStats.color = data.color;
                
                // Apply color to missile
                if (missile && missile.children && missile.children[0]) {
                    missile.children[0].material.color.set(data.color);
                }
                updatePlayerMarkerColor();
            } else {
                // Make sure we save the current color to Firebase instead
                updatePlayerInFirebase();
            }
        } else {
            // First time player, create their record
            updatePlayerInFirebase();
        }
    }).catch(error => {
        console.error("Error fetching player data:", error);
    });
}

// Update player stats in Firebase
function updatePlayerInFirebase() {
    if (!playerStats.firebaseId) return;
    
    db.collection("players").doc(playerStats.firebaseId).set({
        name: playerStats.name,
        tpm: playerStats.tpm,
        targetsDestroyed: playerStats.targetsDestroyed,
        allTimeTargetsDestroyed: playerStats.allTimeTargetsDestroyed || playerStats.targetsDestroyed,
        totalPlayTimeSeconds: playerStats.totalPlayTimeSeconds,
        lastActive: firebase.firestore.FieldValue.serverTimestamp(),
        color: playerStats.color
    }, { merge: true }).catch(error => {
        console.error("Error updating player data:", error);
    });
}

// Subscribe to leaderboard updates
function subscribeToLeaderboard() {
    // Unsubscribe from existing listener
    if (leaderboardListener) {
        leaderboardListener();
        leaderboardListener = null;
    }
    
    // Use get() with periodic refresh instead of continuous listening
    function refreshLeaderboard() {
        db.collection("players")
            .orderBy("tpm", "desc")
            .limit(10) // Reduced from 20
            .get()
            .then(snapshot => {
                const leaderboardData = [];
                snapshot.forEach(doc => {
                    // Process data as before
                    leaderboardData.push({
                        id: doc.id,
                        name: doc.data().name || "Anonymous",
                        tpm: doc.data().tpm || 0,
                        targetsDestroyed: doc.data().targetsDestroyed || 0,
                        color: doc.data().color || "#ff3333"
                    });
                });
                
                leaderboard = leaderboardData;
                updateLeaderboard();
            })
            .catch(error => {
                if (error.code === 'resource-exhausted') {
                    console.warn("Firebase quota exceeded. Retrying later...");
                    // Exponential backoff
                    setTimeout(refreshLeaderboard, 5000);
                } else {
                    console.error("Leaderboard error:", error);
                }
            });
    }
    
    refreshLeaderboard();
    
    // Set up periodic refresh instead of continuous listening
    return setInterval(refreshLeaderboard, 10000); // Every 10 seconds
}

function initializeLeaderboard() {
    console.log("Initializing fresh leaderboard with single collection cleanup...");
    
    // STEP 1: Clear the local leaderboard array completely
    leaderboard = [];
    
    // STEP 2: Add the current player to the leaderboard
    leaderboard.push({
        id: playerStats.id,
        name: playerStats.name,
        targetsDestroyed: playerStats.targetsDestroyed,
        tpm: playerStats.tpm || 0,
        color: playerStats.color
    });
    
    // STEP 3: Add all enemy pilots with fresh stats for this round
    enemyPilotStats.forEach(pilot => {
        // Reset enemy pilot stats before adding to leaderboard
        pilot.targetsDestroyed = 0;
        pilot.crashes = 0;
        pilot.totalPlayTimeSeconds = 0;
        
        leaderboard.push({
            id: pilot.id,
            name: pilot.name,
            targetsDestroyed: pilot.targetsDestroyed,
            tpm: pilot.tpm || 0,
            color: pilot.color || "#66ccff",
            isEnemyPilot: true
        });
    });
    
    // STEP 4: If Firebase is available, perform thorough cleanup of ONLY players collection
    if (window.firestore && firebase.auth().currentUser) {
        const playersCollection = db.collection("players");
        
        // Get ALL players
        playersCollection.get().then(snapshot => {
            console.log(`Found ${snapshot.size} total entries in Firebase`);
            
            // Create batch operations for better atomicity
            const batch = db.batch();
            
            // Delete ALL entries except current player
       //     snapshot.docs.forEach(doc => {
       //         if (doc.id !== playerStats.id) {
       //             console.log(`Removing player: ${doc.data().name || "Unknown"} (${doc.id})`);
      //              batch.delete(doc.ref);
       //         }
       //     });
            
            // Commit the delete operations
            return batch.commit();
        }).then(() => {
            console.log("Successfully cleaned up all Firebase entries");
            
            // Now add fresh NATO enemy pilots with a new batch
            const batch = db.batch();
            
            enemyPilotStats.forEach(pilot => {
                console.log(`Adding NATO pilot to Firebase: ${pilot.name} (${pilot.id})`);
                const pilotRef = playersCollection.doc(pilot.id);
                batch.set(pilotRef, {
                    name: pilot.name,
                    color: pilot.color || "#66ccff",
                    targetsDestroyed: 0, // Always start fresh
                    tpm: 0,
                    isEnemyPilot: true,
                    // Add position tracking fields that were in activePlayers
                    position: { x: 0, y: 0, z: 0 },
                    direction: { x: 0, y: 0, z: 0 },
                    isActive: true,
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                });
            });
            
            return batch.commit();
        }).then(() => {
            console.log("Successfully added NATO pilots to Firebase");
            
            // Update the UI after all Firebase operations are complete
            updateLeaderboard();
            console.log(`Leaderboard initialized with ${leaderboard.length} pilots (NATO only)`);
        }).catch(error => {
            console.error("Firebase operations failed:", error);
            
            // Still update the UI even if Firebase fails
            updateLeaderboard();
        });
    } else {
        // No Firebase available, just update the UI
        updateLeaderboard();
        console.log(`Leaderboard initialized with ${leaderboard.length} pilots (Firebase not available)`);
    }
}
    
   


    function initSoundPool() {
    // Create pre-loaded pool of audio elements
    window.explosionSoundPool = [];
    const poolSize = 5;
    
    for (let i = 0; i < poolSize; i++) {
        const sound = new Audio('explosion.mp3');
        sound.volume = 0.2;
        sound.preload = 'auto';
        window.explosionSoundPool.push(sound);
    }
    
    window.explosionSoundIndex = 0;
    }        

        // Add this function to create a custom material for explosion particles
// Update the createExplosionShaderMaterial function
function createExplosionShaderMaterial(texture, color) {
    return new THREE.ShaderMaterial({
        uniforms: {
            map: { value: texture },
            color: { value: new THREE.Color(color) },
            opacity: { value: 1.0 },
            time: { value: 0.0 } // Add time uniform for animation
        },
        vertexShader: `
            varying vec2 vUv;
            
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform sampler2D map;
            uniform vec3 color;
            uniform float opacity;
            uniform float time;
            
            varying vec2 vUv;
            
            void main() {
                vec4 texColor = texture2D(map, vUv);
                
                // Add subtle flicker to the fire
                float flicker = sin(time * 10.0) * 0.05 + 0.95;
                
                // Enhance reds and yellows, reduce blues
                vec3 adjustedColor = color * texColor.rgb;
                adjustedColor.r *= 1.1; // Boost red channel
                adjustedColor.b *= 0.7; // Reduce blue channel
                
                gl_FragColor = vec4(adjustedColor * flicker, texColor.a * opacity);
            }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        side: THREE.DoubleSide
    });
}

function createHudElements() {
    // Create HUD elements if they don't exist
    const hud = document.getElementById('hud');
    if (!hud) return;
    
    // Clear any existing content
    hud.innerHTML = `
        <div class="hud-container">
            <div class="meter-group">
                <div class="hud-label">ALTITUDE</div>
                <div class="horizontal-meter-container">
                    <div class="horizontal-meter-bar-bg">
                        <div id="altitude-bar" class="horizontal-meter-bar"></div>
                    </div>
                    <div class="meter-tick-marks"></div>
                </div>
                <div id="altitude" class="meter-value">0</div>
                <div class="meter-unit">m</div>
            </div>
            
            <div class="meter-group">
                <div class="hud-label">SPEED</div>
                <div class="horizontal-meter-container">
                    <div class="horizontal-meter-bar-bg">
                        <div id="speed-bar" class="horizontal-meter-bar"></div>
                    </div>
                    <div class="meter-tick-marks"></div>
                </div>
                <div id="speed" class="meter-value">0</div>
                <div class="meter-unit">km/h</div>
            </div>
        </div>
    `;

    // Add CSS for the horizontal HUD
    const style = document.createElement('style');
    style.textContent = `
        #hud {
            font-family: 'Quantico', sans-serif;
            padding: 12px 15px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 1px solid #ff3333;
            border-radius: 5px;
            color: white;
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 18px;
            width: 480px; /* Wide HUD */
        }
        
        .hud-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .meter-group {
            display: flex;
            align-items: center;
            width: 100%;
        }
        
        .hud-label {
            color: #aaaaaa;
            font-weight: bold;
            font-size: 14px;
            width: 75px;
        }
        
        .horizontal-meter-container {
            flex-grow: 1;
            position: relative;
            height: 22px;
            margin: 0 10px;
        }
        
        .horizontal-meter-bar-bg {
            height: 100%;
            width: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid #444;
            position: relative;
        }
        
        .horizontal-meter-bar {
            height: 100%;
            width: 0%; /* Start with zero width */
            background-color: #66ccff;
            position: absolute;
            top: 0;
            left: 0;
            transition: width 0.2s ease-out, background-color 0.3s ease;
        }
        
        /* Tick marks along the bar */
        .horizontal-meter-container::before {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            left: 25%;
            width: 1px;
            background-color: rgba(255, 255, 255, 0.3);
            z-index: 1;
        }
        
        .horizontal-meter-container::after {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            left: 75%;
            width: 1px;
            background-color: rgba(255, 255, 255, 0.3);
            z-index: 1;
        }
        
        .horizontal-meter-bar-bg::before {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            left: 50%;
            width: 1px;
            background-color: rgba(255, 255, 255, 0.3);
            z-index: 1;
        }
        
        .meter-value {
            color: #66ccff;
            font-size: 22px;
            font-weight: bold;
            text-align: right;
            min-width: 45px;
        }
        
        .meter-unit {
            color: #aaaaaa;
            font-size: 14px;
            width: 35px;
            padding-left: 5px;
        }
    `;
    document.head.appendChild(style);
}



    function disposeObject(object) {
    if (!object) return;
    
    // Dispose of geometry
    if (object.geometry) {
        object.geometry.dispose();
    }
    
    // Dispose of material(s) and their textures
    if (object.material) {
        if (Array.isArray(object.material)) {
            object.material.forEach(material => {
                // Handle shader materials
                if (material.isShaderMaterial && material.uniforms.map && 
                    material.uniforms.map.value) {
                    // Don't dispose shared textures (we're still using them elsewhere)
                }
                material.dispose();
            });
        } else {
            // Handle shader materials
            if (object.material.isShaderMaterial && object.material.uniforms.map && 
                object.material.uniforms.map.value) {
                // Don't dispose shared textures (we're still using them elsewhere)
            }
            object.material.dispose();
        }
    }
    
    // Recursively dispose children if it's a group
    if (object.children && object.children.length > 0) {
        for (let i = object.children.length - 1; i >= 0; i--) {
            disposeObject(object.children[i]);
        }
    }
    
    // Remove from parent
    if (object.parent) {
        object.parent.remove(object);
    }
}

// Add mobile optimizations
if (isMobile) {
    // Reduce quality on mobile
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1));
    directionalLight.shadow.mapSize.width = 512;
    directionalLight.shadow.mapSize.height = 512;
    
    // Reduce particle counts
    const MAX_SMOKE_PARTICLES = 5000;
    const MAX_EXPLOSION_PARTICLES = 10000;
    
    // Lower city complexity
    buildingCount = Math.floor(buildingCount * 0.7);
    
    // Disable some effects
    scene.fog.density = 0.0025; // Increase fog density to hide pop-in
}
   
function logResourceCounts(label) {
    console.log(`${label}: `, {
        smokeParticles: smokeParticles.length,
        explosionParticles: explosionParticles.length,
        scorchMarks: scorchMarks.length,
        enemyMissiles: enemyMissiles.length,
        buildings: buildings.length,
        targetBuildings: targetBuildings.length,
        minimapDots: minimapBuildingDots.length,
        geometryCount: renderer.info.memory.geometries,
        textureCount: renderer.info.memory.textures
    });
}

function ensureCameraReferences() {
    // Check if camera exists
    if (!camera) {
        console.warn("Camera not initialized yet");
        return false;
    }
    
    // Make sure userData exists
    if (!camera.userData) {
        camera.userData = {};
    }
    
    // Make sure verticalReferenceFrame exists
    if (!camera.userData.verticalReferenceFrame) {
        camera.userData.verticalReferenceFrame = {
            forward: new THREE.Vector3(0, 0, -1),
            right: new THREE.Vector3(1, 0, 0),
            up: new THREE.Vector3(0, 1, 0)
        };
    }
    
    return true;
}

        function createTerrain() {
            // Create the ground
            const groundGeometry = new THREE.PlaneGeometry(5000, 5000, 200, 200);
             const groundMaterial = new THREE.MeshStandardMaterial({
             color: 0x3d5e3a, // Dark green
              roughness: 0.8,
              metalness: 0.2
              });
              const ground = new THREE.Mesh(groundGeometry, groundMaterial);
              ground.rotation.x = -Math.PI / 2;
             ground.position.y = -0.5;
             ground.receiveShadow = false;
             scene.add(ground);

             // Add city ground plane (replacing roads)
            const cityGroundGeometry = new THREE.PlaneGeometry(citySize * 1.2, citySize * 1.2);
             const cityGroundMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 }); // Grey color
             const cityGround = new THREE.Mesh(cityGroundGeometry, cityGroundMaterial);
             cityGround.rotation.x = -Math.PI / 2;
             cityGround.position.y = -0.4; // higher above main ground
             cityGround.receiveShadow = false;
             scene.add(cityGround);

             // Add more distant fog for horizon effect
            scene.fog = new THREE.FogExp2(0x87CEEB, 0.0005);
            
            // Add some terrain variation outside the city
            for (let i = 0; i < 100; i++) {
                const distance = THREE.MathUtils.randFloat(citySize * 0.8, 800);
                const angle = THREE.MathUtils.randFloat(0, Math.PI * 2);
                const x = Math.cos(angle) * distance;
                const z = Math.sin(angle) * distance;
                
                const hillSize = THREE.MathUtils.randFloat(7, 28);

                const maxHeightRatio = 0.4; // Height can't be more than 40% of width
                const hillHeight = Math.min(hillSize * maxHeightRatio, THREE.MathUtils.randFloat(2, 8));
                
                const hillGeometry = new THREE.ConeGeometry(hillSize, hillHeight, 6);
                const hillMaterial = new THREE.MeshStandardMaterial({
                    color: 0x3d5e3a,
                    roughness: 0.9,
                    metalness: 0.1,
                });
                
                const hill = new THREE.Mesh(hillGeometry, hillMaterial);
                hill.position.set(x, hillHeight / 2 - 0.5, z);
                hill.castShadow = false;
                hill.receiveShadow = false;
                scene.add(hill);
            }

    // Add more hills in countryside
    const countrysideFeatureCount = 300;
    
    for (let i = 0; i < countrysideFeatureCount; i++) {
        // Determine distance from city center - dispersed throughout countryside
        const distanceFromCenter = THREE.MathUtils.randFloat(citySize * 0.8, 2000);
        const angle = THREE.MathUtils.randFloat(0, Math.PI * 2);
        const x = Math.cos(angle) * distanceFromCenter;
        const z = Math.sin(angle) * distanceFromCenter;
        
         // Create hills
        const hillSize = THREE.MathUtils.randFloat(8, 60);

        // Height proportional to size with maximum ratio
        const maxHeightRatio = 0.35; // Even flatter for larger hills
        const hillHeight = Math.min(hillSize * maxHeightRatio, THREE.MathUtils.randFloat(3, 15));
    
    const hillGeometry = new THREE.ConeGeometry(hillSize, hillHeight, 6);
    const hillMaterial = new THREE.MeshStandardMaterial({
        color: new THREE.Color(
            0.2 + Math.random() * 0.1,
            0.4 + Math.random() * 0.2,
            0.2 + Math.random() * 0.1
        ),
        roughness: 0.9,
        metalness: 0.1,
    });
    
    const hill = new THREE.Mesh(hillGeometry, hillMaterial);
    hill.position.set(x, hillHeight / 2 - 0.5, z);
    hill.castShadow = false;
    hill.receiveShadow = false;
    scene.add(hill);
}
    }
        
    function createRoofSigns() {
    // Create a canvas for the BINGO sign texture
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 512;
    canvas.height = 512;
    
    // Fill background
    context.fillStyle = '#ff3333'; // Red background
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    // Add border
    context.strokeStyle = 'white';
    context.lineWidth = 20;
    context.strokeRect(10, 10, canvas.width - 20, canvas.height - 20);
    
    // Add "BINGO" text
    context.font = 'bold 120px Arial';
    context.fillStyle = 'white';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText('BINGO', canvas.width / 2, canvas.height / 2);
    
    // Create texture from canvas
    const texture = new THREE.CanvasTexture(canvas);
    texture.minFilter = THREE.LinearFilter;
    
    // Choose random buildings to add signs to (about 15% of regular buildings)
    buildings.forEach(building => {
        // Skip target buildings and randomly select ~15% of other buildings
        if (!building.userData.isTarget && Math.random() < 0.15) {
            const width = building.userData.width;
            const height = building.userData.height;
            
            // Create sign geometry and material
            const signGeometry = new THREE.PlaneGeometry(width, width); // Square sign
            const signMaterial = new THREE.MeshBasicMaterial({ 
                map: texture, 
                side: THREE.FrontSide
            });
            
            // Create the sign mesh
            const sign = new THREE.Mesh(signGeometry, signMaterial);
            
            // Position sign on top of building, facing upward
            sign.position.copy(building.position);
            sign.position.y = height + 0.1; // Place slightly above the building
            sign.rotation.x = -Math.PI / 2; // Rotate to face upward
            
            // Add to scene
            scene.add(sign);
        }
    });
}    
        
    function createCity() {
    // Clear any existing buildings first
    for (let i = buildings.length - 1; i >= 0; i--) {
        disposeObject(buildings[i]);
    }
    buildings = [];
    targetBuildings = [];
    
    // Calculate the number of target buildings
    const targetCount = Math.floor(buildingCount * targetPercentage);
    stats.targetsRemaining = targetCount;

    // Create a more spacious grid layout with well-defined streets
    const gridSize = 15; // Number of grid cells per side
    const cellSize = citySize / gridSize; // Size of each cell
       
    // Create array to track grid cell occupancy (to avoid overcrowding)
     const positions = [];
    
    // Generate positions on the grid - one building per cell with random size
    for (let x = 0; x < gridSize; x++) {
        for (let z = 0; z < gridSize; z++) {
                        
            // Calculate cell center position
            const cellX = (x - gridSize/2) * cellSize + cellSize/2;
            const cellZ = (z - gridSize/2) * cellSize + cellSize/2;
            
            // Randomize building width (but keep within max limits)
            const width = cellSize * 0.65; 
            
            // Add position to array
            positions.push({
                x: cellX, 
                z: cellZ,
                width: width
            });
            
        }
    }
    
    // Shuffle array for random distribution of target buildings
    for (let i = positions.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [positions[i], positions[j]] = [positions[j], positions[i]];
    }
    
    // Ensure all cells are filled with buildings
      const actualBuildingCount = positions.length; // Use all available positions
        buildingCount = positions.length; // Update buildingCount to match
    
    // Create target buildings (red, short)
    for (let i = 0; i < targetCount && i < actualBuildingCount; i++) {
        const pos = positions[i];
        const height = THREE.MathUtils.randFloat(5, 10);
        const width = pos.width;
        
        const buildingGeometry = new THREE.BoxGeometry(width, height, width);
        const buildingMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xcc0000, 
            roughness: 0.7, 
            metalness: 0.3  
        });
        const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
        
        building.position.set(pos.x, height/2, pos.z);
        building.castShadow = false;
        building.receiveShadow = false;
        building.userData.isTarget = true;
        building.userData.width = width;
        building.userData.height = height;
        
        scene.add(building);
        buildings.push(building);
        targetBuildings.push(building);
    }
    
    // Create regular buildings (gray, varied heights)
    for (let i = targetCount; i < actualBuildingCount; i++) {
        const pos = positions[i];
        
         // Add 5% chance for very tall buildings
         const isSuperTall = Math.random() < 0.05;
        const height = isSuperTall ? 
            THREE.MathUtils.randFloat(120, 180) :  // Very tall buildings 
            THREE.MathUtils.randFloat(20, 100);    // Regular buildings
        
        const width = pos.width;
        
         // Randomize building materials to create variety
         const roughness = THREE.MathUtils.randFloat(0.3, 0.9); // More variation in shininess
        const metalness = THREE.MathUtils.randFloat(0.1, 0.5); // Some buildings more metallic
        
        // More varied colors
        const colorBase = 0.5 + Math.random() * 0.15;
        const colorVariation = Math.random() * 0.1 - 0.05; // Small variations in RGB
        
        const buildingGeometry = new THREE.BoxGeometry(width, height, width);
        const buildingMaterial = new THREE.MeshStandardMaterial({ 
            color: new THREE.Color(
                colorBase + colorVariation,
                colorBase + colorVariation,
                colorBase + colorVariation
            ),
            roughness: roughness,
            metalness: metalness
        });
        const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
        
        building.position.set(pos.x, height/2, pos.z);
        building.castShadow = false;
        building.receiveShadow = false;
        building.userData.isTarget = false;
        building.userData.width = width;
        building.userData.height = height;
        
        scene.add(building);
        buildings.push(building);
    }
    
    // Update HUD
    const targetsElement = document.getElementById('targetsRemaining');
    if (targetsElement) {
    targetsElement.textContent = stats.targetsRemaining;
    }
}
        
function createMissile() {
    // Create missile group
    missile = new THREE.Group();

    ensureCameraReferences();
    
    // Create the main body (cylinder)
    const bodyGeometry = new THREE.CylinderGeometry(1, 1, 8, 16);
    const bodyMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x5c5c5c,  // Use direct color instead of selectedMissileColor
        metalness: 0.3,
        roughness: 0.6
    });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.castShadow = false;
    missile.add(body);
    
    // Create the nose cone (cone)
    const noseGeometry = new THREE.ConeGeometry(1, 3, 16);
    const noseMaterial = new THREE.MeshStandardMaterial({ color: 0x999999 });
    const nose = new THREE.Mesh(noseGeometry, noseMaterial);
    nose.position.y = 5.5;
    nose.castShadow = false;
    missile.add(nose);

    // Create exhaust nozzle (inverted cone)
    const exhaustGeometry = new THREE.CylinderGeometry(1, 0.5, 1.5, 16);
    const exhaustMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x111111, // Very dark gray, almost black
        metalness: 0.8,
        roughness: 0.4
    });
    const exhaust = new THREE.Mesh(exhaustGeometry, exhaustMaterial);
    exhaust.position.y = -4.5; // Position at back of missile
    exhaust.castShadow = false;
    missile.add(exhaust);
            
            // Create fins (4 of them)
            const finGeometry = new THREE.BoxGeometry(0.2, 2, 3);
            const finMaterial = new THREE.MeshStandardMaterial({ color: 0x242424 });
            
            for (let i = 0; i < 4; i++) {
                const fin = new THREE.Mesh(finGeometry, finMaterial);
                fin.position.y = -3;
                fin.castShadow = false;
                
                // Position fins around the missile
                fin.rotation.y = (Math.PI / 2) * i;
                fin.position.x = Math.sin((Math.PI / 2) * i) * 1.2;
                fin.position.z = Math.cos((Math.PI / 2) * i) * 1.2;
                
                missile.userData[`fin${i}`] = fin;
                missile.add(fin);
            }
            
            // Add a glowing exhaust effect using a simple circle mesh
             const glowGeometry = new THREE.CircleGeometry(0.8, 16);
               const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff3300, 
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide,
               depthWrite: false
         });
             exhaustGlow = new THREE.Mesh(glowGeometry, glowMaterial);
              exhaustGlow.position.y = -6; // Position behind the exhaust
             exhaustGlow.rotation.x = Math.PI / 2; // Orient perpendicular to missile direction
             missile.add(exhaustGlow);


            // Add missile to scene
            missile.rotation.x = Math.PI / 2; // Point forward
            scene.add(missile);
            
            // Pick a random spawn point
            resetMissile();
        }
        
        function updateMissileExhaust() {
    if (!exhaustGlow) return;
    
    // Scale the glow based on acceleration
    if (isAccelerating) {
        exhaustGlow.scale.set(1.5, 1.5, 1.5);
        exhaustGlow.material.color.setHex(0xff5500); // Brighter orange
        exhaustGlow.material.opacity = 0.95;
    } else {
        exhaustGlow.scale.set(1.0, 1.0, 1.0);
        exhaustGlow.material.color.setHex(0xff3300); // Regular red/orange
        exhaustGlow.material.opacity = 0.8;
    }
    
    // Add a subtle pulse effect
    const pulseAmount = 0.1 * Math.sin(Date.now() * 0.01);
    exhaustGlow.scale.x += pulseAmount;
    exhaustGlow.scale.y += pulseAmount;
}

function setupMinimap() {
    // Get the parent element
    const minimapParent = document.getElementById('minimap');
    minimapParent.innerHTML = '';
    
    // Set parent styling
    minimapParent.style.width = '350px';
    minimapParent.style.height = '350px';
    minimapParent.style.position = 'absolute';
    minimapParent.style.bottom = '20px';
    minimapParent.style.left = '20px';
    minimapParent.style.overflow = 'hidden';
    minimapParent.style.border = '2px solid #ff3333';
    minimapParent.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
    
    // Create container that WILL rotate
    minimapContainer = document.createElement('div');
    minimapContainer.style.width = '100%';
    minimapContainer.style.height = '100%';
    minimapContainer.style.position = 'relative';
    minimapContainer.style.transformOrigin = 'center center';
    minimapParent.appendChild(minimapContainer);
    
    // Create minimap renderer
    minimapRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    minimapRenderer.setSize(350, 350);
    minimapRenderer.setClearColor(0x000000, 0.5);
    minimapRenderer.domElement.style.position = 'absolute';
    minimapContainer.appendChild(minimapRenderer.domElement);
    
    // Create minimap scene
    minimapScene = new THREE.Scene();
    
    // Create orthographic camera for minimap
    const viewExtent = citySize * 0.6;
    minimapCamera = new THREE.OrthographicCamera(
        -viewExtent, viewExtent, viewExtent, -viewExtent, 1, 1000
    );
    minimapCamera.position.set(0, 400, 0);
    minimapCamera.lookAt(0, 0, 0);
    minimapCamera.up.set(0, 0, -1); // North is up
    
    // Create city representation
    const cityPlaneGeometry = new THREE.PlaneGeometry(citySize, citySize);
    const cityPlaneMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x444444, 
        transparent: true,
        opacity: 0.5
    });
    const cityPlane = new THREE.Mesh(cityPlaneGeometry, cityPlaneMaterial);
    cityPlane.rotation.x = -Math.PI / 2;
    minimapScene.add(cityPlane);

    // Initialize square building markers for minimap
    initializeMinimapMarkers();
    
    // IMPORTANT: Create player marker mesh
    const playerMarkerSize = 10;
    const playerTriangleShape = new THREE.Shape();
    playerTriangleShape.moveTo(0, -playerMarkerSize);
    playerTriangleShape.lineTo(-playerMarkerSize * 0.6, playerMarkerSize * 0.5);
    playerTriangleShape.lineTo(playerMarkerSize * 0.6, playerMarkerSize * 0.5);
    playerTriangleShape.lineTo(0, -playerMarkerSize);


    
    const playerTriangleGeometry = new THREE.ShapeGeometry(playerTriangleShape);
    
    // Use player's color or default gray
    const markerColor = playerStats.color || '#5c5c5c';
    const markerMaterial = new THREE.MeshBasicMaterial({
        color: new THREE.Color(markerColor),
        side: THREE.DoubleSide
    });
    
    // Create the marker mesh
    playerMarker = new THREE.Mesh(playerTriangleGeometry, markerMaterial);
    playerMarker.rotation.x = Math.PI / 2; // Flat on the XZ plane
    playerMarker.position.y = 2.0; // Slightly above ground
    
    // Set initial position (will be updated in updateMinimap)
    if (missile && missile.position) {
        playerMarker.position.x = missile.position.x;
        playerMarker.position.z = missile.position.z;
    }
    
    // Add player marker to the scene
    minimapScene.add(playerMarker);
    
    // Add compass indicator
    addMinimapCompass();
}

function initializeMinimapMarkers() {
    // Create pools for building markers on minimap
    if (!window.minimapDotPool) {
        window.minimapDotPool = {
            target: [],
            regular: [],
            // Square geometries instead of circles
            geometryTarget: new THREE.PlaneGeometry(8, 8), // Larger size for targets (was ~3-4)
            geometryRegular: new THREE.PlaneGeometry(6, 6), // Larger size for regular buildings (was ~2-3)
            materialTarget: new THREE.MeshBasicMaterial({
                color: 0xff3333, // Red for targets
                side: THREE.DoubleSide
            }),
            materialRegular: new THREE.MeshBasicMaterial({
                color: 0xaaaaaa, // Gray for regular buildings
                side: THREE.DoubleSide
            })
        };
    }

    // Initialize empty arrays if not existing
    window.minimapBuildingDots = window.minimapBuildingDots || [];
}

function updatePlayerMarkerColor() {
  // Only proceed if we have both the player marker and a valid color
  if (playerMarker && playerStats.color) {
    // Update the marker material color
    if (playerMarker.material) {
      playerMarker.material.color.set(playerStats.color);
    }
    
    console.log(`Updated player marker color to ${playerStats.color}`);
  }
}


function addMinimapCompass() {
    // Create small direction markers (N, E, S, W)
    const directions = [
        { label: "N", position: new THREE.Vector3(0, 0, -citySize * 0.7), color: 0x66ccff },
        { label: "E", position: new THREE.Vector3(citySize * 0.7, 0, 0), color: 0xffffff },
        { label: "S", position: new THREE.Vector3(0, 0, citySize * 0.7), color: 0xffffff },
        { label: "W", position: new THREE.Vector3(-citySize * 0.7, 0, 0), color: 0xffffff }
    ];
    
    directions.forEach(dir => {
        // Create a canvas for the text
        const canvas = document.createElement('canvas');
        canvas.width = 32;
        canvas.height = 32;
        const ctx = canvas.getContext('2d');
        
        // Draw the text
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.font = 'bold 20px Arial';
        ctx.fillStyle = `#${dir.color.toString(16).padStart(6, '0')}`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(dir.label, canvas.width/2, canvas.height/2);
        
        // Create texture and sprite
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.SpriteMaterial({ map: texture });
        const sprite = new THREE.Sprite(material);
        sprite.position.copy(dir.position);
        sprite.position.y = 2; // Slightly above ground
        sprite.scale.set(10, 10, 1);
        
        minimapScene.add(sprite);
    });
}

// Update the updateMinimap 
function updateMinimap() {
    if (!gameActive) return;
    
    // Always rotate the container with fixed rotation
    if (minimapContainer && typeof minimapFixedRotation !== 'undefined') {
        minimapContainer.style.transform = `rotate(${-minimapFixedRotation}rad)`;
    }
    
    // Update player marker position and rotation using THREE.js (like enemy markers)
    if (playerMarker && missile && missile.position && missileDirection) {
        // Update position
        playerMarker.position.x = missile.position.x;
        playerMarker.position.z = missile.position.z;
        
        // Update rotation
        const angle = Math.atan2(missileDirection.x, -missileDirection.z);
        playerMarker.rotation.set(Math.PI / 2, 0, angle);
    }
    
    // Update and render
    updateMinimapBuildings();
    updateEnemyMinimapMarkers();
    
    if (minimapRenderer && minimapScene && minimapCamera) {
        minimapRenderer.render(minimapScene, minimapCamera);
    }
}

// New function to update enemy missile markers on the minimap
function updateEnemyMinimapMarkers() {
    // Make sure we have the array initialized
    if (!window.enemyMinimapMarkers) {
        window.enemyMinimapMarkers = [];
    }
    
    // Remove any excess markers
    while (window.enemyMinimapMarkers.length > enemyMissiles.length) {
        const marker = window.enemyMinimapMarkers.pop();
        minimapScene.remove(marker);
        disposeObject(marker);
    }
    
    // Create triangle shape for enemies once
    if (!window.enemyTriangleGeometry) {
        const enemyTriangleShape = new THREE.Shape();
        const enemyMarkerSize = 8; // Slightly smaller than player
        enemyTriangleShape.moveTo(0, -enemyMarkerSize);
        enemyTriangleShape.lineTo(-enemyMarkerSize * 0.6, enemyMarkerSize * 0.5);
        enemyTriangleShape.lineTo(enemyMarkerSize * 0.6, enemyMarkerSize * 0.5);
        enemyTriangleShape.lineTo(0, -enemyMarkerSize);
        
        window.enemyTriangleGeometry = new THREE.ShapeGeometry(enemyTriangleShape);
    }
    
    // Create new markers or update existing ones
    for (let i = 0; i < enemyMissiles.length; i++) {
        const enemyMissile = enemyMissiles[i];
        let marker = window.enemyMinimapMarkers[i];
        
        // Create new marker if needed
        if (!marker) {
            // Try to get color from missile's userData
            let markerColor;
            if (enemyMissile.userData && enemyMissile.userData.pilotId) {
                // Find the pilot's color
                const pilot = enemyPilotStats.find(p => p.id === enemyMissile.userData.pilotId);
                if (pilot && pilot.color) {
                    markerColor = new THREE.Color(pilot.color);
                } else {
                    // Fallback color
                    markerColor = new THREE.Color(0x66ccff);
                }
            } else {
                // Fallback color
                markerColor = new THREE.Color(0x66ccff);
            }
            
            const markerMaterial = new THREE.MeshBasicMaterial({
                color: markerColor,
                side: THREE.DoubleSide
            });
            
            marker = new THREE.Mesh(window.enemyTriangleGeometry, markerMaterial);
            marker.rotation.x = Math.PI / 2; // Start flat on the XZ plane
            marker.position.y = 1.5; // Slightly lower than player marker
            
            minimapScene.add(marker);
            window.enemyMinimapMarkers.push(marker);
        }
        
        // Update marker position
        marker.position.x = enemyMissile.position.x;
        marker.position.z = enemyMissile.position.z;
        
        // Update direction - use enemy missile direction
        if (enemyMissile.userData && enemyMissile.userData.direction) {
            const dir = enemyMissile.userData.direction;
            const angle = Math.atan2(dir.x, -dir.z);
            marker.rotation.set(Math.PI / 2, 0, angle);
        }
    }
}

    // Convert missile direction to cardinal direction (N, NE, E, etc.)
function getCardinalDirection(direction) {
    // Calculate angle in degrees (0 is north, increases clockwise)
    let angle = Math.atan2(direction.x, direction.z) * (180 / Math.PI);
    if (angle < 0) angle += 360;
    
    // Map angle to cardinal direction
    if (angle >= 337.5 || angle < 22.5) return "N";
    if (angle >= 22.5 && angle < 67.5) return "NE";
    if (angle >= 67.5 && angle < 112.5) return "E";
    if (angle >= 112.5 && angle < 157.5) return "SE";
    if (angle >= 157.5 && angle < 202.5) return "S";
    if (angle >= 202.5 && angle < 247.5) return "SW";
    if (angle >= 247.5 && angle < 292.5) return "W";
    if (angle >= 292.5 && angle < 337.5) return "NW";
    
    return "N/A"; // Fallback
}

function createPortalRings() {
    // Portal ring properties
    const portalRadius = 30; // Large enough to fly through
    const tubeRadius = 2.5;  // Thickness of the ring
    const tubularSegments = 48; // Smoothness around the circumference
    const radialSegments = 16;  // Smoothness along the tube
    const portalDistance = citySize * 2.5; // Distance from center - increased
    const portalHeight = 70; // Higher off the ground
    
    // Create geometry for all portals (torus shape)
    const portalGeometry = new THREE.TorusGeometry(
        portalRadius, tubeRadius, radialSegments, tubularSegments
    );
    
    // Material with glow effect
    const portalMaterial = new THREE.ShaderMaterial({
        uniforms: {
            time: { value: 0 }
        },
        vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform float time;
            varying vec2 vUv;
            void main() {
                float pulse = 0.5 + 0.5 * sin(time * 2.0);
                vec3 color = vec3(0.0, 0.8 + 0.2 * pulse, 0.3 + 0.3 * pulse);
                float edge = 0.05;
                float edgeGlow = smoothstep(0.5 - edge, 0.5, vUv.x) * 
                                 smoothstep(0.5 - edge, 0.5, 1.0 - vUv.x);
                gl_FragColor = vec4(color * (0.7 + 0.3 * pulse), 0.9);
            }
        `,
        transparent: true,
        side: THREE.DoubleSide
    });
    
    // Define the cardinal directions for portal placement
    const cardinalDirections = [
        { name: "North", position: new THREE.Vector3(0, 0, portalDistance), facing: new THREE.Vector3(0, 0, -1) },
        { name: "South", position: new THREE.Vector3(0, 0, -portalDistance), facing: new THREE.Vector3(0, 0, 1) },
        { name: "East", position: new THREE.Vector3(portalDistance, 0, 0), facing: new THREE.Vector3(-1, 0, 0) },
        { name: "West", position: new THREE.Vector3(-portalDistance, 0, 0), facing: new THREE.Vector3(1, 0, 0) }
    ];
    
    // Array to store all portal references
    window.portalRings = [];
    
    // Create portal pairs in each cardinal direction
    cardinalDirections.forEach(dir => {
        // "Back" portal - slightly offset to the left
        const backPortal = new THREE.Mesh(portalGeometry, portalMaterial.clone());
        backPortal.position.copy(dir.position);
        backPortal.position.y = portalHeight; // Raised higher
        
        // Apply offset based on direction (left side of the pair)
        if (dir.name === "North" || dir.name === "South") {
            backPortal.position.x -= portalRadius * 2.5;
            backPortal.rotation.x = 0;
                
            // For South portal, also rotate 180 around Y to face North
            if (dir.name === "South") {
                backPortal.rotation.y = Math.PI;
            }
        } else {
            // East/West portals
            backPortal.rotation.x = Math.PI / 2;
            backPortal.position.z += portalRadius * 2.5;
            if (dir.name === "East") {
                backPortal.rotation.y = Math.PI / 2;
            } else if (dir.name === "West") {
                backPortal.rotation.y = -Math.PI / 2;
            }
        }
        
        scene.add(backPortal);
        backPortal.userData.isPortal = true;
        backPortal.userData.destination = "back";
        backPortal.userData.direction = dir.name;
        backPortal.userData.normal = dir.facing;
        
        // Create portal label
        createPortalLabel(backPortal, "Vibeverse portals", "Back");
        window.portalRings.push(backPortal);
        
        // "Next" portal - slightly offset to the right
        const nextPortal = new THREE.Mesh(portalGeometry, portalMaterial.clone());
        nextPortal.position.copy(dir.position);
        nextPortal.position.y = portalHeight; // Raised higher
        
        // Apply offset based on direction (right side of the pair)
        if (dir.name === "North" || dir.name === "South") {
            nextPortal.rotation.x = 0;
                        
            if (dir.name === "South") {
                nextPortal.rotation.y = Math.PI;
            }
        } else {
            nextPortal.rotation.x = Math.PI / 2;
            
            if (dir.name === "East") {
                nextPortal.rotation.y = Math.PI / 2;
            } else if (dir.name === "West") {
                nextPortal.rotation.y = -Math.PI / 2;
            }
        }
        
        scene.add(nextPortal);
        nextPortal.userData.isPortal = true;
        nextPortal.userData.destination = "next";
        nextPortal.userData.direction = dir.name;
        nextPortal.userData.normal = dir.facing;
        
        // Create portal label
        createPortalLabel(nextPortal, "Vibeverse portals", "Next");
        window.portalRings.push(nextPortal);
    });

}

function createPortalLabel(portal, mainText, subText) {
    // Create canvas for text
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 512;
    canvas.height = 256;
    
    // Fill with transparent background
    context.fillStyle = 'rgba(0, 0, 0, 0.0)';
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    // Add main text with glow
    context.font = 'bold 36px Arial';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    
    // Glow effect
    context.shadowColor = '#00ff77';
    context.shadowBlur = 15;
    context.fillStyle = '#ffffff';
    context.fillText(mainText, canvas.width / 2, canvas.height / 3);
    
    // Add sub text below
    context.font = 'bold 48px Arial';
    context.fillText(subText, canvas.width / 2, canvas.height * 2/3);
    
    // Create texture and material
    const texture = new THREE.CanvasTexture(canvas);
    const labelMaterial = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,
        side: THREE.DoubleSide
    });
    
    // Create label plane
    const labelGeometry = new THREE.PlaneGeometry(50, 25);
    const label = new THREE.Mesh(labelGeometry, labelMaterial);
    
    // Position label above the portal
    label.position.copy(portal.position);
    label.position.y += 45; // Position higher above the portal
    
    // Make ALL text face toward the city center for readability
    // First, get direction from portal to city center
    const dirToCity = new THREE.Vector3().subVectors(
        new THREE.Vector3(0, label.position.y, 0), // City center at same height
        label.position
    ).normalize();
    
    // Make the label face the city
    const labelDirection = new THREE.Vector3(0, 0, 1); // Default forward vector
    label.quaternion.setFromUnitVectors(labelDirection, dirToCity);
    
    scene.add(label);
    
    // Store reference to label
    portal.userData.label = label;
}


function checkPortalCollisions() {
    if (!gameActive || resetDelay > 0 || !missile.visible) return false;
    
    if (!window.portalRings) return false;
    
    // Check each portal
    for (const portal of window.portalRings) {
        // Distance to portal center
        const portalPos = portal.position;
        const distToPortalCenter = missile.position.distanceTo(portalPos);
        
        // Check if close to portal
        if (distToPortalCenter < 40) {
            // More precise collision check - are we passing through the ring?
            // Vector from missile to portal center
            const toPortal = new THREE.Vector3().subVectors(portalPos, missile.position);
            
            // Get portal facing direction (stored in userData)
            const portalNormal = portal.userData.normal;
            
            // Distance to portal plane
            const distToPlane = toPortal.dot(portalNormal);
            
            // If we're close to the portal plane and within ring radius
            if (Math.abs(distToPlane) < 5) {
                // Project missile position onto portal plane to get position within ring
                const projectedPoint = missile.position.clone().add(
                    portalNormal.clone().multiplyScalar(distToPlane)
                );
                
                // Check distance from projected point to portal center (in the plane)
                projectedPoint.y -= portalPos.y; // Adjust for portal height
                const distInRing = new THREE.Vector2(
                    projectedPoint.x - portalPos.x, 
                    projectedPoint.z - portalPos.z
                ).length();
                
                // If within the ring, trigger portal effect!
                if (distInRing < portal.geometry.parameters.radius - 5) {
                    console.log(`Entered ${portal.userData.destination} portal in ${portal.userData.direction} direction!`);
                    
                    // Create transition effect
                    createPortalTransitionEffect(portal);
                    
                    // Navigate to destination
                    navigateToPortalDestination(portal);
                    
                    return true; // Portal entered
                }
            }
        }
    }
    
    return false;
}

// Create visual effect for portal transition
function createPortalTransitionEffect(portal) {
    const flash = document.createElement('div');
    flash.style.position = 'fixed';
    flash.style.top = '0';
    flash.style.left = '0';
    flash.style.width = '100%';
    flash.style.height = '100%';
    flash.style.backgroundColor = portal.userData.destination === 'next' ? '#00ff77' : '#3366ff';
    flash.style.opacity = '0';
    flash.style.transition = 'opacity 0.8s';
    flash.style.pointerEvents = 'none';
    flash.style.zIndex = '1000';
    document.body.appendChild(flash);
    
    // Fade in
    setTimeout(() => {
        flash.style.opacity = '0.6';
    }, 10);
}

// Navigate to portal destination
function navigateToPortalDestination(portal) {
    // Get destination URL based on portal type
    let destinationUrl;
    
    if (portal.userData.destination === 'back' && entryPortalRef) {
        // This is a "back" portal, go to where player came from if available
        destinationUrl = entryPortalRef;
    } else {
        // This is a "next" portal, go to portal.pieter.com
        destinationUrl = portalConfig.next;
    }
    
    // Add query parameters
    const params = new URLSearchParams();
    params.append('portal', 'true');
    params.append('username', playerStats.name);
    params.append('color', playerStats.color || '0x5C5C5C');  // Default to grey
    params.append('speed', Math.round(velocity * 20)); // Convert to compatible speed units
    
    // Add ref parameter (where player is coming from)
    params.append('ref', portalConfig.self); // Base URL without params
    
    // Combine URL with params
    const fullUrl = destinationUrl.includes('?') 
        ? `${destinationUrl}&${params.toString()}`
        : `${destinationUrl}?${params.toString()}`;

        // Create visual effect for transition
    createPortalTransitionEffect(portal);
    
    // Pause the game
    gameActive = false;
    
    // Navigate after the transition animation
    setTimeout(() => {
        window.location.href = fullUrl;
    }, 1000);
}

function handleIncomingPortal() {
    const urlParams = new URLSearchParams(window.location.search);
    
    // Check if player came through a portal
    if (urlParams.get('portal') === 'true') {
        console.log("Player arrived through portal!");
        
        // Store reference to previous game for "Back" portal
        entryPortalRef = urlParams.get('ref');
        
        // Set player name if provided
        if (urlParams.get('username')) {
            playerStats.name = urlParams.get('username');
        }
        
        // Set missile color if provided
        if (urlParams.get('color')) {
            const incomingColor = urlParams.get('color');
            playerStats.color = incomingColor;
            
            // Apply color to missile
            if (missile && missile.children && missile.children[0]) {
                missile.children[0].material.color.set(incomingColor);
            }
        }
        
        // Set incoming speed if provided
        if (urlParams.get('speed')) {
            const incomingSpeed = parseFloat(urlParams.get('speed'));
            if (!isNaN(incomingSpeed)) {
                // Map the incoming speed to our game's velocity scale
                velocity = Math.max(baseVelocity, Math.min(maxVelocity, incomingSpeed / 20));
            }
        }
        
         // Skip start menu, go directly to game
         gameActive = true;
        
        // Show welcome message
        showPortalWelcomeMessage();
    }
}

        
function resetMissile() {
    // Reset crash flag
    handleCrash.inProgress = false;

    if (camera) {
        camera.up.set(0, 1, 0);
    }
    
    // Safely reset reference frame
    if (ensureCameraReferences()) {
        camera.userData.verticalReferenceFrame = {
            forward: new THREE.Vector3().copy(missileDirection).normalize(),
            right: new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), missileDirection).normalize(),
            up: new THREE.Vector3(0, 1, 0)
        };
    }

    // Choose random spawn point
    const spawnIndex = Math.floor(Math.random() * spawnPoints.length);
    currentSpawnPoint = spawnPoints[spawnIndex].clone();
    
    // Move spawn point slightly inward so portal is behind the player
    // This vector points from spawn point toward city center
    const towardCityVector = new THREE.Vector3()
        .subVectors(new THREE.Vector3(0, currentSpawnPoint.y, 0), currentSpawnPoint)
        .normalize()
        .multiplyScalar(60); // Move 60 units closer to city
    
    currentSpawnPoint.add(towardCityVector);
    
    // Set missile position
    missile.position.copy(currentSpawnPoint);
    missile.visible = true;
    
    // Set initial direction based on spawn point (always toward city center)
    missileDirection.set(-currentSpawnPoint.x, 0, -currentSpawnPoint.z);
    if (missileDirection.length() < 0.1) {
        // Fallback for edge case
        missileDirection.set(0, 0, -1);
    }
    missileDirection.normalize();
    
    // Make sure it's not heading too much up or down
    missileDirection.y = 0;
    missileDirection.normalize();



    // IMPORTANT: Calculate fixed minimap rotation ONCE - the angle needed to make 
    // the player enter from the bottom of the minimap
    // This is the angle between the initial direction and the "down" direction (0,0,1)
    minimapFixedRotation = Math.atan2(missileDirection.x, -missileDirection.z);
    
    updateMinimap(); // Update minimap to show new position
    
    // Align missile with direction
    const missileRotation = new THREE.Quaternion().setFromUnitVectors(
        new THREE.Vector3(0, 1, 0), 
        missileDirection
    );
    missile.quaternion.copy(missileRotation);

    // Reset camera's up vector to be level
    camera.up.set(0, 1, 0);
    
    // Reset reference frame
    camera.userData.verticalReferenceFrame = {
        forward: new THREE.Vector3().copy(missileDirection).normalize(),
        right: new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), missileDirection).normalize(),
        up: new THREE.Vector3(0, 1, 0)
    };
    
    // Reset velocity
    velocity = baseVelocity;
    turnVelocity.set(0, 0, 0);
    isAccelerating = false;
    
    // Reset flight time
    startTime = Date.now();
    elapsedTime = 0;
    
    // Don't reset camera position immediately - it will be handled by updateCamera()
    // The key is to let the smoothing system handle the transition naturally
}
        
        /*
        function createFireAndSmoke() {
        // Check if we're at the particle limit
        if (smokeParticles.length > MAX_SMOKE_PARTICLES) {
        // Remove oldest particles if we're at the limit
        const removeCount = Math.min(20, smokeParticles.length - MAX_SMOKE_PARTICLES + 20);
        for (let i = 0; i < removeCount; i++) {
            const oldParticle = smokeParticles.shift(); // Remove oldest first
            disposeObject(oldParticle);
        }
    }

    // Create particle group for fire
    const fireCount = isAccelerating ? 6 : 2; // Less fire when not accelerating
   
    for (let i = 0; i < fireCount; i++) {
        // More varied sizes for fire
        const fireSize = isAccelerating ? 
            THREE.MathUtils.randFloat(1.0, 2.0) : 
            THREE.MathUtils.randFloat(0.6, 1.2);
        
        // Create more complex fire meshes (sphere + light)
        const fireGeometry = new THREE.SphereGeometry(fireSize, 8, 8);
        
        // More vibrant colors for fire
        const colorRandom = Math.random();
        const fireColor = colorRandom < 0.3 ? 
            0xffff00 : // Yellow
            (colorRandom < 0.7 ? 0xff5500 : 0xff2200); // Orange or Red
        
        const fireMaterial = new THREE.MeshBasicMaterial({
            color: fireColor,
            transparent: true,
            opacity: THREE.MathUtils.randFloat(0.7, 1.0) // Higher opacity
        });
        
        const fire = new THREE.Mesh(fireGeometry, fireMaterial);
        
        // Position fire behind missile with more variance for accelerating
        const missileBackVector = missileDirection.clone().negate();
        const backDistance = isAccelerating ? 
            THREE.MathUtils.randFloat(3, 7) : 
            THREE.MathUtils.randFloat(2, 5);
        
        fire.position.copy(missile.position)
            .add(missileBackVector.clone().multiplyScalar(backDistance))
            .add(new THREE.Vector3(
                THREE.MathUtils.randFloatSpread(isAccelerating ? 1.0 : 0.5),
                THREE.MathUtils.randFloatSpread(isAccelerating ? 1.0 : 0.5),
                THREE.MathUtils.randFloatSpread(isAccelerating ? 1.0 : 0.5)
            ));
        
        // Add point light for glow effect on largest particles
        if (fireSize > 1.5 && isAccelerating) {
            const fireLight = new THREE.PointLight(fireColor, 2, 8);
            fireLight.position.copy(fire.position);
            scene.add(fireLight);
            
            // Store light in fire's userData
            fire.userData.light = fireLight;
        }
        
        // Fire behavior
        fire.userData = {
            life: THREE.MathUtils.randFloat(0.3, 0.7),
            maxLife: THREE.MathUtils.randFloat(0.3, 0.7),
            velocity: missileBackVector.clone().multiplyScalar(
                isAccelerating ? 
                THREE.MathUtils.randFloat(0.2, 0.5) : 
                THREE.MathUtils.randFloat(0.1, 0.3)
            )
        };
        
        scene.add(fire);
        smokeParticles.push(fire);
    }

    
    
    // Create smoke particles
    if (!isAccelerating || Math.random() > 0.3) {
        const smokeCount = isAccelerating ? 1 : 2; // More smoke when not accelerating
        
        for (let i = 0; i < smokeCount; i++) {
            const smokeGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const smokeMaterial = new THREE.MeshBasicMaterial({
                color: 0x888888,
                transparent: true,
                opacity: 0.4
            });
            
            const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
        
            // Position smoke behind missile 
            const missileBackVector = missileDirection.clone().negate();
            smoke.position.copy(missile.position)
                .add(missileBackVector.multiplyScalar(6))
                .add(new THREE.Vector3(
                    THREE.MathUtils.randFloatSpread(1), 
                    THREE.MathUtils.randFloatSpread(1), 
                    THREE.MathUtils.randFloatSpread(1)  
                ));
                    
            // Corrected from 'fire' to 'smoke'
            smoke.userData = {
                life: 1.0,
                maxLife: 1.0,
                growRate: THREE.MathUtils.randFloat(1.02, 1.05),
                velocity: new THREE.Vector3(
                    THREE.MathUtils.randFloatSpread(0.1),
                    THREE.MathUtils.randFloat(0.05, 0.2),
                    THREE.MathUtils.randFloatSpread(0.1)
                )
            };
                
            scene.add(smoke);
            smokeParticles.push(smoke);
        }
    }
}
    */

    function initEnemyExplosionMaterials() {
    // Instead of creating different materials, we'll use the same shader materials
    // as player explosions to ensure consistent visuals for all explosions
    
    // Initialize the player explosion materials first if needed
    if (!explosionMaterialPool.yellow) {
        initExplosionTextures();
    }
    
    // Share the same material pool for consistency
    enemyExplosionMaterialPool.yellow = explosionMaterialPool.yellow;
    enemyExplosionMaterialPool.orange = explosionMaterialPool.orange;
    enemyExplosionMaterialPool.red = explosionMaterialPool.red;
}

    function initExplosionTextures() {
    // Create shared textures
    if (!window.explosionTextures) {
        window.explosionTextures = {
            yellow: createExplosionTextureWithColor('#ffff40'),  
            orange: createExplosionTextureWithColor('#ff8000'),  
            red: createExplosionTextureWithColor('#ff2000')      
        };
        
        // Create reusable shader materials (instead of MeshBasicMaterial)
        explosionMaterialPool.yellow = createExplosionShaderMaterial(
            window.explosionTextures.yellow,
            0xffff40
        );
        
        explosionMaterialPool.orange = createExplosionShaderMaterial(
            window.explosionTextures.orange,
            0xff8000
        );
        
        explosionMaterialPool.red = createExplosionShaderMaterial(
            window.explosionTextures.red,
            0xff2000
        );
    }
}

function createExplosionTextureWithColor(color) {
    // Create a texture for explosion particles
    const canvas = document.createElement('canvas');
    canvas.width = 64;
    canvas.height = 64;
    const ctx = canvas.getContext('2d');
    
    const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
    
    // Use warmer colors with no blue/green tints
    if (color.includes('ff')) { // Red/orange variants
        gradient.addColorStop(0, color);
        gradient.addColorStop(0.7, color.replace('ff', '40'));
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
    } else {
        gradient.addColorStop(0, '#ffdd40'); // Warm yellow default
        gradient.addColorStop(0.7, '#ff6600');
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
    }
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 64, 64);
    
    return new THREE.CanvasTexture(canvas);
}

function createExplosion(position, isPlayerEvent = false, createGroundScorch = true) {
    // Create a more dramatic multi-stage explosion
    const isLargeExplosion = isPlayerEvent; // Player explosions should be larger
    
    // Calculate core fireball and debris counts based on importance
    const maxFireballParticles = isPlayerEvent ? 30 : 20;  // Increased from 15 to 20
    const maxDebrisParticles = isPlayerEvent ? 40 : 25;    // Increased from 20 to 25 
    const maxSecondaryParticles = isPlayerEvent ? 20 : 12; // Increased from 10 to 12
    
    // STAGE 1: Initial fireball (bright center, fast expansion)
    createExplosionCore(position, maxFireballParticles, true);
    
    // STAGE 2: Flying debris (with trails)
    setTimeout(() => {
        if (gameActive) createExplosionDebris(position, maxDebrisParticles, true);
    }, 50);
    
    // STAGE 3: Secondary blast wave
    setTimeout(() => {
        if (gameActive) createExplosionSecondary(position, maxSecondaryParticles, true);
    }, 150);
    
    // Handle remaining explosion logic - create a scorch mark but NO smoke from explosion directly
    if (createGroundScorch) {
        createScorchMark(position, false);
    }
    
    // Sound and shake effects
    if (isPlayerEvent) {
        screenShakeTime = 2.0;  // Longer shake
        screenShakeIntensity = 3.0; // More intense shake
        playSound('explosion');
    } else {
        // Add smaller screen shake for enemy explosions too
        screenShakeTime = 1.0;
        screenShakeIntensity = 1.5;
        playEnemyExplosionSound(); 
    }
}

// CORE EXPLOSION - bright expanding fireball
function createExplosionCore(position, count, isLarge) {
    // Create the shared texture if it doesn't exist yet
    if (!window.explosionCoreTexture) {
        // Create a better explosion texture with internal structure
        const canvas = document.createElement('canvas');
        canvas.width = 128;
        canvas.height = 128;
        const ctx = canvas.getContext('2d');
        
        // Create multi-layered explosion gradient with more internal detail
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        
        // Base glow
        const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, canvas.width/2);
        gradient.addColorStop(0, 'rgba(255, 255, 220, 1.0)');    // White-hot center
        gradient.addColorStop(0.2, 'rgba(255, 240, 160, 0.9)');  // Bright yellow
        gradient.addColorStop(0.4, 'rgba(255, 180, 50, 0.8)');   // Deep orange
        gradient.addColorStop(0.7, 'rgba(200, 50, 10, 0.5)');    // Dark red
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');           // Transparent edge
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Add some texture/noise for more realistic fire
        ctx.globalCompositeOperation = 'overlay';
        for (let i = 0; i < 30; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const r = Math.random() * 20 + 5;
            
            const noiseGrad = ctx.createRadialGradient(x, y, 0, x, y, r);
            noiseGrad.addColorStop(0, `rgba(255, 255, 255, ${Math.random() * 0.4})`);
            noiseGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = noiseGrad;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
        }
        
        window.explosionCoreTexture = new THREE.CanvasTexture(canvas);
    }
    
    // Create core fireball particles
    const geometry = new THREE.PlaneGeometry(1, 1);
    
    for (let i = 0; i < count; i++) {
        // Create shader material with emissive effect
        const material = new THREE.ShaderMaterial({
            uniforms: {
                map: { value: window.explosionCoreTexture },
                // Brighter color for enemy explosions to make them more visible
                color: { value: new THREE.Color(isLarge ? 0xffbb44 : 0xffcc55) }, 
                time: { value: 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D map;
                uniform vec3 color;
                uniform float time;
                varying vec2 vUv;
                
                void main() {
                    vec4 texColor = texture2D(map, vUv);
                    
                    // Pulse effect
                    float pulse = 0.9 + 0.1 * sin(time * 12.0);
                    
                    // Enhance warm colors
                    vec3 warmColor = color * texColor.rgb;
                    warmColor.r *= 1.2 * pulse;
                    warmColor.g *= 1.0 * pulse;
                    warmColor.b *= 0.8;
                    
                    gl_FragColor = vec4(warmColor, texColor.a);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            side: THREE.DoubleSide
        });
        
        const particle = new THREE.Mesh(geometry, material);
        particle.position.copy(position.clone());
        
        // Make enemy explosion fireballs slightly larger to be more visible
        // Size still depends on whether it's player or enemy
        const size = isLarge ? 
            THREE.MathUtils.randFloat(3.0, 8.0) : 
            THREE.MathUtils.randFloat(2.5, 7.0); // Increased size for enemy fireballs
            
        particle.scale.set(size, size, 1);
        
        // Randomized outward velocity but keep particles closer to center
        const angle = Math.random() * Math.PI * 2;
        const elevation = (Math.random() * Math.PI - Math.PI/2) * 0.6; // Biased toward horizontal
        const speed = THREE.MathUtils.randFloat(8, isLarge ? 20 : 18); // Slightly slower for enemy missiles
        
        const velocity = new THREE.Vector3(
            Math.cos(angle) * Math.cos(elevation) * speed,
            Math.sin(elevation) * speed,
            Math.sin(angle) * Math.cos(elevation) * speed
        );
        
        // Slightly longer lifetime for enemy fireballs to make them more noticeable
        const lifetime = isLarge ? 
            THREE.MathUtils.randFloat(0.8, 1.6) :
            THREE.MathUtils.randFloat(1.0, 1.8); // Increased lifetime
            
        // Make fireball grow rapidly at first, then fade
        particle.userData = {
            life: lifetime,
            maxLife: lifetime,
            velocity: velocity,
            isBillboard: true,
            isFireball: true,
            growthPhase: true,
            growthTime: THREE.MathUtils.randFloat(0.3, 0.5), // Time spent growing
            maxGrowth: isLarge ? THREE.MathUtils.randFloat(1.8, 2.5) : THREE.MathUtils.randFloat(1.7, 2.3), // Increased enemy growth
            initialScale: size,
            acceleration: new THREE.Vector3(0, isLarge ? 2 : 1.5, 0) // Increased upward acceleration
        };
        
        scene.add(particle);
        explosionParticles.push(particle);
    }
}

// DEBRIS PARTICLES - streaking particles with trails
function createExplosionDebris(position, count, isLarge) {
    if (!window.debrisTexture) {
        // Create streak/ember texture for debris
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        
        // Create elongated particle for streaking effect
        const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        gradient.addColorStop(0, 'rgba(255, 220, 170, 1.0)');  // Bright core
        gradient.addColorStop(0.4, 'rgba(255, 120, 40, 0.8)');  // Orange middle
        gradient.addColorStop(0.7, 'rgba(180, 40, 10, 0.5)');   // Darker edge
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');         // Transparent
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 64, 64);
        
        window.debrisTexture = new THREE.CanvasTexture(canvas);
    }
    
    const geometry = new THREE.PlaneGeometry(1, 1);
    
    for (let i = 0; i < count; i++) {
        // Pick temperature based on random value (hotter = yellower)
        const temperature = Math.random();
        let color;
        
        if (temperature > 0.7) {
            color = new THREE.Color(0xffee33); // Hot yellow
        } else if (temperature > 0.4) {
            color = new THREE.Color(0xff9922); // Orange
        } else {
            color = new THREE.Color(0xff3311); // Red
        }
        
        // Create material with streak effect
        const material = new THREE.ShaderMaterial({
            uniforms: {
                map: { value: window.debrisTexture },
                color: { value: color },
                time: { value: 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D map;
                uniform vec3 color;
                uniform float time;
                varying vec2 vUv;
                
                void main() {
                    vec4 texColor = texture2D(map, vUv);
                    
                    // Slight pulsing glow effect
                    float pulse = 0.9 + 0.1 * sin(time * 15.0);
                    
                    vec3 finalColor = color * texColor.rgb * pulse;
                    gl_FragColor = vec4(finalColor, texColor.a);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            side: THREE.DoubleSide
        });
        
        const particle = new THREE.Mesh(geometry, material);
        
        // Slightly randomize initial position for more chaotic look
        particle.position.copy(position.clone().add(
            new THREE.Vector3(
                THREE.MathUtils.randFloatSpread(isLarge ? 2 : 1),
                THREE.MathUtils.randFloatSpread(isLarge ? 2 : 1),
                THREE.MathUtils.randFloatSpread(isLarge ? 2 : 1)
            )
        ));
        
        // Smaller debris particles that stretch based on velocity
        const size = THREE.MathUtils.randFloat(1.0, 2.5);
        particle.scale.set(size, size, 1);
        
        // Higher velocity for streaking effect
        const angle = Math.random() * Math.PI * 2;
        const elevation = Math.random() * Math.PI - Math.PI/2;
        const speed = THREE.MathUtils.randFloat(25, 60); // High speed for streaks
        
        const velocity = new THREE.Vector3(
            Math.cos(angle) * Math.cos(elevation) * speed,
            Math.sin(elevation) * speed,
            Math.sin(angle) * Math.cos(elevation) * speed
        );
        
        // Add gravity and drag effects
        particle.userData = {
            life: THREE.MathUtils.randFloat(0.6, 1.2),
            maxLife: THREE.MathUtils.randFloat(0.6, 1.2),
            velocity: velocity,
            isBillboard: true,
            isDebris: true,
            initialScale: size,
            rotationSpeed: new THREE.Vector3(
                Math.random() * 0.2 - 0.1,
                Math.random() * 0.2 - 0.1,
                Math.random() * 0.2 - 0.1
            ),
            gravity: 20, // Higher gravity for arcing effect
            drag: THREE.MathUtils.randFloat(0.2, 0.4) // Air resistance
        };
        
        scene.add(particle);
        explosionParticles.push(particle);
    }
}

// SECONDARY EXPANSION WAVE - outward expanding ring
function createExplosionSecondary(position, count, isLarge) {
    if (!window.secondaryTexture) {
        // Create shockwave-like texture
        const canvas = document.createElement('canvas');
        canvas.width = 128;
        canvas.height = 128;
        const ctx = canvas.getContext('2d');
        
        // Create dual-layer gradient for more complex effect
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        
        // First layer - central glow
        const gradient1 = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, canvas.width/2);
        gradient1.addColorStop(0, 'rgba(255, 180, 80, 0.8)'); // Orange core
        gradient1.addColorStop(0.5, 'rgba(200, 100, 30, 0.4)'); // Mid orange
        gradient1.addColorStop(0.7, 'rgba(150, 50, 20, 0.2)'); // Darker edge
        gradient1.addColorStop(1, 'rgba(0, 0, 0, 0)'); // Transparent edge
        
        ctx.fillStyle = gradient1;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        window.secondaryTexture = new THREE.CanvasTexture(canvas);
    }
    
    const geometry = new THREE.PlaneGeometry(1, 1);
    
    for (let i = 0; i < count; i++) {
        const material = new THREE.ShaderMaterial({
            uniforms: {
                map: { value: window.secondaryTexture },
                color: { value: new THREE.Color(0xff9944) },
                time: { value: 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D map;
                uniform vec3 color;
                uniform float time;
                varying vec2 vUv;
                
                void main() {
                    vec4 texColor = texture2D(map, vUv);
                    
                    // Dynamic color adjustment based on time
                    vec3 adjustedColor = color;
                    adjustedColor.r *= (1.0 + 0.1 * sin(time * 8.0));
                    
                    gl_FragColor = vec4(adjustedColor * texColor.rgb, texColor.a);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            side: THREE.DoubleSide
        });
        
        const particle = new THREE.Mesh(geometry, material);
        
        // Position with slight random offset
        particle.position.copy(position.clone().add(
            new THREE.Vector3(
                THREE.MathUtils.randFloatSpread(1),
                THREE.MathUtils.randFloatSpread(1) + 1, // Slightly higher
                THREE.MathUtils.randFloatSpread(1)
            )
        ));
        
        // Larger size for wave effect
        const size = isLarge ? 
            THREE.MathUtils.randFloat(5.0, 10.0) : 
            THREE.MathUtils.randFloat(3.0, 7.0);
            
        particle.scale.set(size, size, 1);
        
        // Slower outward velocity for wave effect
        const angle = Math.random() * Math.PI * 2;
        const elevation = (Math.random() * Math.PI - Math.PI/2) * 0.5; // More horizontal
        const speed = THREE.MathUtils.randFloat(5, 15); // Slower speed
        
        const velocity = new THREE.Vector3(
            Math.cos(angle) * Math.cos(elevation) * speed,
            Math.sin(elevation) * speed * 0.5, // Reduced vertical component
            Math.sin(angle) * Math.cos(elevation) * speed
        );
        
        // Wave particles expand rapidly
        particle.userData = {
            life: THREE.MathUtils.randFloat(0.8, 1.4),
            maxLife: THREE.MathUtils.randFloat(0.8, 1.4),
            velocity: velocity,
            isBillboard: true,
            isWave: true,
            initialScale: size,
            growRate: 1.08, // Fast growth
            fadeRate: 0.7 // Quick fade after expanding
        };
        
        scene.add(particle);
        explosionParticles.push(particle);
    }
}


    
   



function createDamagedBuildingSmoke(position, damageLevel) {
    // Skip if we're at particle limit
    if (smokeParticles.length > MAX_SMOKE_PARTICLES * 0.9) return;
    
    // Create smoke with size based on damage
    const smokeSize = THREE.MathUtils.randFloat(2.0, 4.0) * Math.sqrt(damageLevel);
    const smokeGeometry = new THREE.PlaneGeometry(1, 1);
    
    // Make sure the billowy texture exists before using it
    if (!window.billowyTexture) {
        const canvas = document.createElement('canvas');
        canvas.width = 128;
        canvas.height = 128;
        const ctx = canvas.getContext('2d');
        
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        
        // Create soft-edged cloud-like gradient (consistently gray)
        const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, canvas.width/2);
        gradient.addColorStop(0, 'rgba(80, 80, 80, 0.9)'); // Dense center
        gradient.addColorStop(0.5, 'rgba(70, 70, 70, 0.6)'); // Mid-density
        gradient.addColorStop(0.8, 'rgba(60, 60, 60, 0.3)'); // Light edge
        gradient.addColorStop(1, 'rgba(60, 60, 60, 0)'); // Transparent edge
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Add some texture for more realistic smoke
        ctx.globalCompositeOperation = 'overlay';
        for (let i = 0; i < 20; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const r = Math.random() * 25 + 5;
            
            const cloudGrad = ctx.createRadialGradient(x, y, 0, x, y, r);
            cloudGrad.addColorStop(0, `rgba(255, 255, 255, ${Math.random() * 0.2})`);
            cloudGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = cloudGrad;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
        }
        
        window.billowyTexture = new THREE.CanvasTexture(canvas);
    }
    
    // ALWAYS use billowyTexture for consistency, never fall back to scorchSmokeTexture
    const smokeTexture = window.billowyTexture;
    
    const smokeMaterial = new THREE.MeshBasicMaterial({
        map: smokeTexture,
        transparent: true,
        depthWrite: false,
        opacity: THREE.MathUtils.randFloat(0.4, 0.7) * damageLevel,
        side: THREE.DoubleSide
    });
    
    const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
    smoke.scale.set(smokeSize, smokeSize, 1);
    
    // Position exactly at source point without offset
    smoke.position.copy(position);
    
    // Add upward velocity with some randomness - INCREASED VERTICAL VELOCITY
    const velocity = new THREE.Vector3(
        THREE.MathUtils.randFloatSpread(0.3) + globalWindDirection.x,
        THREE.MathUtils.randFloat(4.0, 7.0), // Dramatically increased for tall plumes
        THREE.MathUtils.randFloatSpread(0.3) + globalWindDirection.z
    );
    
    // Make smoke last longer to allow it to rise higher before disappearing
    smoke.userData = {
        life: THREE.MathUtils.randFloat(4.0, 6.0) * damageLevel, // Increased lifetime for taller plumes
        maxLife: THREE.MathUtils.randFloat(4.0, 6.0) * damageLevel,
        growRate: THREE.MathUtils.randFloat(1.01, 1.02),
        velocity: velocity,
        isBillboard: true,
        source: 'building',
        rotationSpeed: new THREE.Vector3(0, 0, THREE.MathUtils.randFloatSpread(0.1))
    };
    
    scene.add(smoke);
    smokeParticles.push(smoke);
}

function addBuildingDamage(building) {
    // Skip if it's already in the damaged buildings list
    if (damagedBuildings.includes(building)) {
        // Just increase damage level if already damaged
        building.userData.damageLevel = Math.min(1.0, building.userData.damageLevel + 0.3);
        return;
    }
    
    // Initialize damage level
    building.userData.damageLevel = 0.5;
    
    // Add to damaged buildings array
    damagedBuildings.push(building);
    
    // Optionally, darken the building to show damage
    if (building.material) {
        building.material.color.multiplyScalar(0.7);
    }
    
    // IMPORTANT: Create initial smoke burst immediately
    // This ensures smoke appears right when the building is damaged
    for (let i = 0; i < 5; i++) {
        const smokeSource = new THREE.Vector3(
            building.position.x + THREE.MathUtils.randFloatSpread(building.userData.width * 0.5),
            building.position.y + building.userData.height * 0.5,
            building.position.z + THREE.MathUtils.randFloatSpread(building.userData.width * 0.5)
        );
        createDamagedBuildingSmoke(smokeSource, building.userData.damageLevel);
    }
}
        

function updateScorchMarks(delta) {
    smokeTimer += delta;
    
    // Only process smoke generation on a timer
    if (smokeTimer < globalSmokeInterval || scorchMarks.length === 0) return;
    
    // Reset timer
    smokeTimer = 0;
    
    // Update wind direction occasionally
    if (Math.random() < 0.1) {
        globalWindDirection.set(
            Math.random() * 0.4 - 0.2,  // Slight x drift
            0,                          // No vertical wind
            Math.random() * 0.4 - 0.2   // Slight z drift
        ).normalize().multiplyScalar(0.3);
    }
    
    // Process scorch marks for smoke emission
    for (let i = 0; i < scorchMarks.length; i++) {
        const scorch = scorchMarks[i];
        if (!scorch || !scorch.userData || !scorch.userData.smokeEnabled) continue;
        
        // Calculate age as a ratio (0 = fresh, 1 = expired)
        const age = (Date.now() - scorch.userData.creationTime);
        const ageRatio = Math.min(1, age / scorch.userData.flickerDuration);
        
        // Skip old scorch marks
        if (ageRatio > 0.8) continue;
        
        // More smoke for fresh scorches, less as they age
        const smokeThreshold = 1 - Math.pow(ageRatio, 0.5); // Non-linear falloff
        const isTargetHit = scorch.userData.isTargetHit;
        
        // Calculate emission probability based on age and type
        const emissionChance = globalSmokeChance * smokeThreshold * scorch.userData.smokeIntensity;
        
        // Target hits create more dramatic rising smoke columns
        if (isTargetHit && ageRatio < 0.6 && Math.random() < emissionChance) {
            // Create larger rising smoke
            createDramaticScorchSmoke(scorch, true);
            
            // 40% chance for additional smoke particles to create denser effect
            if (Math.random() < 0.4) {
                setTimeout(() => {
                    if (scorch.userData.smokeEnabled) {
                        createDramaticScorchSmoke(scorch, false);
                    }
                }, Math.random() * 200); // Slight delay for varied emission
            }
        } 
        // Regular scorch marks emit simpler smoke
        else if (Math.random() < emissionChance * 0.5) {
            createDramaticScorchSmoke(scorch, false);
        }
    }
    
    // Process damaged buildings together with scorches
    updateDamagedBuildingsSmoke();
}

function createDramaticScorchSmoke(scorch, isLarge = false) {
    // Skip if we're at particle limit
    if (smokeParticles.length > MAX_SMOKE_PARTICLES * 0.9) return;
    
    // Create a shared smoke texture if it doesn't exist
    if (!window.scorchSmokeTexture) {
        const canvas = document.createElement('canvas');
        canvas.width = 128;
        canvas.height = 128;
        const ctx = canvas.getContext('2d');
        
        // Create a more detailed smoke texture
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        
        // Create main cloud-like gradient
        const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, canvas.width/2);
        gradient.addColorStop(0, 'rgba(50, 50, 50, 1.0)');
        gradient.addColorStop(0.4, 'rgba(60, 60, 60, 0.8)');
        gradient.addColorStop(0.7, 'rgba(70, 70, 70, 0.4)');
        gradient.addColorStop(1, 'rgba(80, 80, 80, 0)');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Add texture noise for more realistic smoke
        ctx.globalCompositeOperation = 'overlay';
        for (let i = 0; i < 30; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const r = Math.random() * 20 + 5;
            
            const cloudGrad = ctx.createRadialGradient(x, y, 0, x, y, r);
            cloudGrad.addColorStop(0, `rgba(255, 255, 255, ${Math.random() * 0.2})`);
            cloudGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = cloudGrad;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
        }
        
        window.scorchSmokeTexture = new THREE.CanvasTexture(canvas);
    }

     // Get the scorch mark scale to determine smoke size
     const scorchScale = scorch.scale.x || 1.0;
    
    // Create billboarded plane for smoke
    const baseSize = isLarge ? 
        THREE.MathUtils.randFloat(6.0, 9.0) : 
        THREE.MathUtils.randFloat(3.0, 6.0);

        // scale smoke size based on scorch size
        const scaleFactor = Math.pow(scorchScale / 8.0, 0.8); // Use power function for better scaling
    const smokeSize = baseSize * Math.max(1.0, scaleFactor);
        
    const smokeGeometry = new THREE.PlaneGeometry(1, 1);
    const smokeMaterial = new THREE.MeshBasicMaterial({
        map: window.scorchSmokeTexture,
        transparent: true,
        depthWrite: false,
        opacity: THREE.MathUtils.randFloat(0.5, 0.8),
        side: THREE.DoubleSide
    });
    
    const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
    smoke.scale.set(smokeSize, smokeSize, 1);
    
    // Position smoke with variation
    const positionVariance = Math.min(2.5 * scaleFactor, 6.0);
    const heightVariance = Math.min(2.5 * scaleFactor, 6.0);

    const scorchPos = scorch.position.clone();
    smoke.position.copy(scorchPos).add(
        new THREE.Vector3(
            THREE.MathUtils.randFloatSpread(1.5),
            THREE.MathUtils.randFloat(0.5, isLarge ? 4.0 : 2.0),
            THREE.MathUtils.randFloatSpread(1.5)
        )
    );
    
    // Billboard to face camera
    smoke.userData.isBillboard = true;

    // Smoke behavior - make large smoke last longer
    const lifeMultiplier = scorch.userData.isTargetHit ? 1.5 : 1.0;
    
    // Smoke behavior
    smoke.userData = {
        life: isLarge ? THREE.MathUtils.randFloat(3, 5) : THREE.MathUtils.randFloat(2, 3),
        maxLife: isLarge ? THREE.MathUtils.randFloat(3, 5) : THREE.MathUtils.randFloat(2, 3),
        growRate: THREE.MathUtils.randFloat(1.005, 1.015),
        velocity: new THREE.Vector3(
            globalWindDirection.x + THREE.MathUtils.randFloatSpread(0.2),
            THREE.MathUtils.randFloat(isLarge ? 1.0 : 0.5, isLarge ? 2.5 : 1.5),
            globalWindDirection.z + THREE.MathUtils.randFloatSpread(0.2)
        ),
        rotationSpeed: new THREE.Vector3(0, 0, THREE.MathUtils.randFloatSpread(0.1)),
        isBillboard: true,
        source: 'scorch'
    };
    
    scene.add(smoke);
    smokeParticles.push(smoke);
}

function createBillboardSmoke() {
    // Create a single shared texture for all smoke billboards
    if (!window.smokeTexture) {
        // Create the smoke texture procedurally
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        
        // Create radial gradient for a soft smoke puff
        const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        gradient.addColorStop(0, 'rgba(40, 40, 40, 1.0)');
        gradient.addColorStop(0.3, 'rgba(40, 40, 40, 0.8)');
        gradient.addColorStop(0.7, 'rgba(40, 40, 40, 0.1)');
        gradient.addColorStop(1, 'rgba(40, 40, 40, 0)');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 64, 64);
        
        window.smokeTexture = new THREE.CanvasTexture(canvas);
    }
    
    // Create a simple plane that will always face the camera
    const smokeGeometry = new THREE.PlaneGeometry(1, 1);
    const smokeMaterial = new THREE.MeshBasicMaterial({
        map: window.smokeTexture,
        transparent: true,
        opacity: 0.7,
        depthWrite: false,
        side: THREE.DoubleSide
    });
    
    return { geometry: smokeGeometry, material: smokeMaterial };
}

// Create a single timer to update all scorch marks
function updateScorchEffects() {
    // Skip if no scorch marks
    if (scorchMarks.length === 0) return;
    
    for (let i = scorchMarks.length - 1; i >= 0; i--) {
        const scorch = scorchMarks[i];
        const embers = scorch.userData.emberEffect;
        if (!embers) continue;
        
        const age = (Date.now() - scorch.userData.creationTime);
        
        // Remove if too old
        if (age > scorch.userData.flickerDuration) {
            embers.material.opacity = 0;
            continue;
        }
        
        // Random flickering
        const flickerIntensity = Math.random() * 0.3 + 0.2;
        
        // Fade out over time
        const agePercent = age / scorch.userData.flickerDuration;
        embers.material.opacity = flickerIntensity * (1 - agePercent);
    }
}

// Create smoldering particle effect
function createSmolderingParticle(position) {
    if (smokeParticles.length > MAX_SMOKE_PARTICLES * 0.8) return;

    const smokeSize = THREE.MathUtils.randFloat(0.3, 0.7);
    const smokeGeometry = new THREE.SphereGeometry(smokeSize, 8, 8);
    
    // Start with red/orange color and transition to gray/black
    const smokeColor = new THREE.Color(0xff3300); // Initial red/orange
    const smokeMaterial = new THREE.MeshBasicMaterial({
        color: smokeColor,
        transparent: true,
        opacity: THREE.MathUtils.randFloat(0.4, 0.7)
    });
    
    const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
    
    // Add small offset to position for variation
    smoke.position.copy(position).add(
        new THREE.Vector3(
            THREE.MathUtils.randFloatSpread(2),
            THREE.MathUtils.randFloat(0.5, 2),
            THREE.MathUtils.randFloatSpread(2)
        )
    );
    
    // Smoke behavior properties
    smoke.userData = {
        life: THREE.MathUtils.randFloat(1, 2),
        maxLife: THREE.MathUtils.randFloat(1, 2.5),
        growRate: THREE.MathUtils.randFloat(1.01, 1.03),
        velocity: new THREE.Vector3(
            THREE.MathUtils.randFloatSpread(0.2),
            THREE.MathUtils.randFloat(0.5, 1.0),
            THREE.MathUtils.randFloatSpread(0.2)
        ),
        // Color transition data
        initialColor: new THREE.Color(0xff3300),
        finalColor: new THREE.Color(0x222222)
    };
    
    scene.add(smoke);
    smokeParticles.push(smoke);
}

function createSmokeColumn(position, height = 15) {
    // Skip if we're at particle limit
    if (smokeParticles.length > MAX_SMOKE_PARTICLES * 0.9) return;
    
    // Create a cylinder for the smoke column
    const columnGeometry = new THREE.CylinderGeometry(
        2,    // top radius - wider at top
        0.8,  // bottom radius - narrower at bottom
        height, // height of column
        8,    // segments
        5,    // height segments
        true  // open ended
    );
    
    // Create gradient material that's more transparent at edges
    const columnMaterial = new THREE.ShaderMaterial({
        transparent: true,
        depthWrite: false,
        uniforms: {
            time: { value: 0 },
            opacity: { value: 0.6 }
        },
        vertexShader: `
            varying vec2 vUv;
            varying float vHeight;
            void main() {
                vUv = uv;
                vHeight = position.y;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform float time;
            uniform float opacity;
            varying vec2 vUv;
            varying float vHeight;
            void main() {
                // Calculate distance from center of cylinder
                float distFromCenter = abs(vUv.x - 0.5) * 2.0;
                
                // More transparent at edges and top
                float edgeFade = smoothstep(0.9, 0.7, distFromCenter);
                float heightFade = smoothstep(0.0, 1.0, vHeight/10.0);
                
                // Noise-like effect using vUv
                float noise = fract(sin(vUv.x * 12.345 + vUv.y * 67.890 + time) * 43758.5453);
                
                gl_FragColor = vec4(0.2, 0.2, 0.2, opacity * edgeFade * (1.0-heightFade) * (0.7 + 0.3 * noise));
            }
        `
    });
    
    const column = new THREE.Mesh(columnGeometry, columnMaterial);
    column.position.copy(position);
    column.position.y += height / 2; // Position bottom at the source point
    
    // Add to scene 
    scene.add(column);
    
    // Special userData for smoke column
    column.userData = {
        isColumn: true,
        life: 10.0,
        maxLife: 10.0,
        startHeight: height,
        velocity: new THREE.Vector3(0, 0.05, 0), // Very slow rise
        startTime: Date.now() / 1000
    };
    
    smokeParticles.push(column);
    
    // Add this to your animate loop:
    column.material.uniforms.time.value = Date.now() / 1000 - column.userData.startTime;
}
        
function updateParticles(delta) {
    // Update smoke particles
    for (let i = smokeParticles.length - 1; i >= 0; i--) {
        const particle = smokeParticles[i];
        if (!particle) continue;
        
        // Update life
        particle.userData.life -= delta;
        
        // Remove if dead
        if (particle.userData.life <= 0) {
            // Remove associated light if it exists
            if (particle.userData.light) {
                scene.remove(particle.userData.light);
            }
            
            scene.remove(particle);
            disposeObject(particle);
            smokeParticles.splice(i, 1);
            continue;
        }
        
        // Make billboards face camera
        if (particle.userData.isBillboard) {
            particle.lookAt(camera.position);
        }
        
        // Update position
        if (particle.userData.velocity) {
            tempVec3.copy(particle.userData.velocity).multiplyScalar(delta);
            particle.position.add(tempVec3);
        }
        
        // Update size for smoke
        if (particle.userData.growRate) {
            particle.scale.multiplyScalar(particle.userData.growRate);
        }
        
        // Update rotation
        if (particle.userData.rotationSpeed) {
            particle.rotation.x += particle.userData.rotationSpeed.x * delta;
            particle.rotation.y += particle.userData.rotationSpeed.y * delta;
            particle.rotation.z += particle.userData.rotationSpeed.z * delta;
        }
        
        // Update opacity
        const lifeRatio = particle.userData.life / particle.userData.maxLife;
        if (particle.material && particle.material.opacity !== undefined) {
            particle.material.opacity = lifeRatio * 0.8;
        }
    }
    
    // Update explosion particles with improved behavior for different types
    for (let i = explosionParticles.length - 1; i >= 0; i--) {
        const particle = explosionParticles[i];
        if (!particle) continue;
        
        // Update life
        if (particle.userData.life !== undefined) {
            particle.userData.life -= delta;
            
            // Remove if dead
            if (particle.userData.life <= 0) {
                scene.remove(particle);
                disposeObject(particle);
                explosionParticles.splice(i, 1);
                continue;
            }
            
            // Make billboards face camera 
            if (particle.userData.isBillboard) {
                particle.lookAt(camera.position);
            }
            
            // Update position with velocity
            if (particle.userData.velocity) {
                // Apply acceleration if defined
                if (particle.userData.acceleration) {
                    particle.userData.velocity.add(
                        particle.userData.acceleration.clone().multiplyScalar(delta)
                    );
                }
                
                // Apply gravity for debris particles
                if (particle.userData.gravity) {
                    particle.userData.velocity.y -= particle.userData.gravity * delta;
                }
                
                // Apply drag if specified
                if (particle.userData.drag) {
                    particle.userData.velocity.multiplyScalar(1 - (particle.userData.drag * delta));
                }
                
                // Update position
                tempVec3.copy(particle.userData.velocity).multiplyScalar(delta);
                particle.position.add(tempVec3);
            }
            
            // Calculate life ratio for effects
            const lifeRatio = particle.userData.life / particle.userData.maxLife;
            
            // Handle specific particle types
            if (particle.userData.isFireball) {
                // Enhanced fireball behavior with growth phase
                if (particle.userData.growthPhase && 
                    lifeRatio > (1 - particle.userData.growthTime / particle.userData.maxLife)) {
                    // Growth phase - expand rapidly
                    const growthProgress = (1 - lifeRatio) / (particle.userData.growthTime / particle.userData.maxLife);
                    const targetScale = particle.userData.initialScale * 
                        (1 + growthProgress * (particle.userData.maxGrowth - 1));
                    
                    particle.scale.set(targetScale, targetScale, 1);
                } else {
                    // Decay phase - slowly shrink
                    particle.userData.growthPhase = false;
                    const size = particle.scale.x * 0.98;
                    particle.scale.set(size, size, 1);
                }
                
                // Update color/intensity through shader uniforms
                if (particle.material && particle.material.uniforms) {
                    particle.material.uniforms.time.value += delta;
                }
                
                // Update opacity based on life
                if (particle.material && particle.material.uniforms && particle.material.uniforms.color) {
                    // Fade out more rapidly at the end
                    const opacity = lifeRatio < 0.3 ? lifeRatio * lifeRatio * 3 : lifeRatio;
                    
                    // Also shift color from yellow->orange->red as it ages
                    const color = particle.material.uniforms.color.value;
                    if (lifeRatio < 0.5) {
                        // Shift toward red in the second half of life
                        color.g = 0.8 * lifeRatio + 0.2;
                        color.b = 0.2 * lifeRatio;
                    }
                }
            } 
            else if (particle.userData.isDebris) {
                // Debris stretches in direction of movement
                if (particle.userData.velocity.lengthSq() > 1) {
                    // Calculate direction of travel
                    const direction = particle.userData.velocity.clone().normalize();
                    
                    // Calculate stretch factor based on speed
                    const speed = particle.userData.velocity.length();
                    const stretchFactor = Math.min(3, 1 + speed * 0.02);
                    
                    // Apply stretch to scale
                    const baseScale = particle.userData.initialScale * (lifeRatio * 0.8 + 0.2);
                    particle.scale.set(
                        baseScale * stretchFactor,
                        baseScale,
                        1
                    );
                    
                    // Align with velocity direction
                    const upVector = new THREE.Vector3(0, 1, 0);
                    particle.quaternion.setFromUnitVectors(upVector, direction);
                    
                    // Then face camera (billboarded debris)
                    particle.lookAt(camera.position);
                }
                
                // Update color through shader
                if (particle.material && particle.material.uniforms) {
                    particle.material.uniforms.time.value += delta;
                }
            }
            else if (particle.userData.isWave) {
                // Wave particles expand outward
                if (particle.userData.growRate) {
                    particle.scale.multiplyScalar(particle.userData.growRate * 
                        (0.95 + 0.1 * Math.cos(Date.now() * 0.01))); // Slight pulsing
                }
                
                // Update color and opacity
                if (particle.material && particle.material.uniforms) {
                    particle.material.uniforms.time.value += delta;
                    
                    // Fade out more aggressively
                    const fadeRatio = Math.pow(lifeRatio, particle.userData.fadeRate);
                    particle.material.opacity = fadeRatio;
                }
            }
            else {
                // Generic explosion particles
                // Scale down as they age
                const scale = particle.userData.initialScale * (lifeRatio * 0.7 + 0.3);
                particle.scale.set(scale, scale, 1);
                
                // Update shader time if it exists
                if (particle.material && particle.material.uniforms && particle.material.uniforms.time) {
                    particle.material.uniforms.time.value += delta;
                }
            }
        }
    }
}
    
        
function updateHUD() {
    if (!gameActive) return;
    
    // Update altitude
    const altitude = Math.round(missile.position.y);
    const altitudePercent = Math.min(100, (altitude / 800) * 100);
    const altitudeBar = document.getElementById('altitude-bar');
    const altitudeValue = document.getElementById('altitude');
    
    if (altitudeBar && altitudeValue) {
        altitudeBar.style.width = `${altitudePercent}%`; // Changed from height to width
        altitudeValue.textContent = altitude;
        
        // Color based on altitude
        let altitudeColor;
        if (altitude < 50) {
            altitudeColor = '#ff3333'; // Danger - red
        } else if (altitude < 100) {
            altitudeColor = '#ffcc00'; // Warning - yellow
        } else {
            altitudeColor = '#33cc33'; // Safe - green
        }
        
        altitudeBar.style.backgroundColor = altitudeColor;
        altitudeValue.style.color = altitudeColor;
    }
    
    // Update speed
    const speed = Math.round(velocity * 100);
    const speedPercent = Math.min(100, (velocity / (maxVelocity * 0.5)) * 100);
    const speedBar = document.getElementById('speed-bar');
    const speedValue = document.getElementById('speed');
    
    if (speedBar && speedValue) {
        speedBar.style.width = `${speedPercent}%`; // Changed from height to width
        speedValue.textContent = speed;
        
        // Color based on speed
        let speedColor;
        if (speedPercent > 80) {
            speedColor = '#ff3333'; // High speed - red
        } else if (speedPercent > 50) {
            speedColor = '#ffcc00'; // Medium speed - yellow
        } else {
            speedColor = '#33cc33'; // Low speed - green
        }
        
        speedBar.style.backgroundColor = speedColor;
        speedValue.style.color = speedColor;
    }
}

function listenForOtherPlayers(playersCollection) {
    console.log("Setting up listener for other players using consolidated collection...");
    
    try {
        // Unsubscribe from any existing listener
        if (window.otherPlayersListener) {
            window.otherPlayersListener();
            window.otherPlayersListener = null;
        }
        
        // Listen for active players changes with error handling
        window.otherPlayersListener = playersCollection
            .where("isActive", "==", true) // Only show active players
            .onSnapshot(snapshot => {
                snapshot.docChanges().forEach(change => {
                    const playerId = change.doc.id;
                    
                    // Skip current player
                    if (playerId === playerStats.id) return;
                    
                    if (change.type === "added" || change.type === "modified") {
                        updateOtherPlayer(playerId, change.doc.data());
                    } else if (change.type === "removed") {
                        removeOtherPlayer(playerId);
                    }
                });
                
                updatePlayerCountUI();
            }, error => {
                console.error("Error listening for other players:", error);
            });
    } catch (error) {
        console.error("Error setting up player listener:", error);
    }
}

function updatePlayerCountUI() {
    // Count players
    const count = Object.keys(otherPlayers).length + 1; // +1 for local player
    
    // Create or update the counter
    let counter = document.getElementById('player-counter');
    if (!counter) {
        counter = document.createElement('div');
        counter.id = 'player-counter';
        counter.style.position = 'absolute';
        counter.style.top = '10px';
        counter.style.left = '50%';
        counter.style.transform = 'translateX(-50%)';
        counter.style.background = 'rgba(0,0,0,0.6)';
        counter.style.color = '#66ccff';
        counter.style.padding = '5px 15px';
        counter.style.borderRadius = '20px';
        counter.style.fontFamily = 'Quantico, sans-serif';
        counter.style.fontWeight = 'bold';
        counter.style.fontSize = '16px';
        counter.style.zIndex = '1000';
        document.body.appendChild(counter);
    }
    
    // Update the text
    counter.textContent = `Players: ${count}`;
    
    // Highlight if more than one player
    counter.style.color = count > 1 ? '#66ff66' : '#66ccff';
    
    console.log(`Current player count: ${count}`);
    return count;
}

// Setup presence detection to handle disconnects
function setupPlayerPresence(playerRef) {
    if (!window.firebaseDB) {
        console.error("Realtime Database not available for presence detection");
        return;
    }
    
    try {
        console.log("Setting up presence detection");
        const playerId = playerStats.id;
        
        // Use Realtime Database for presence
        const presenceRef = window.firebaseDB.ref(`presence/${playerId}`);
        
        // When this device disconnects, remove this player from presence
        presenceRef.onDisconnect().remove()
            .then(() => {
                // Successfully configured onDisconnect
                console.log("Disconnect cleanup configured successfully");
                
                // Now write the presence data
                presenceRef.set({
                    online: true,
                    lastActive: firebase.database.ServerValue.TIMESTAMP,
                    name: playerStats.name,
                    color: playerStats.color
                }).then(() => {
                    console.log("Presence data written successfully");
                }).catch(error => {
                    console.error("Error writing presence data:", error);
                });
            })
            .catch(error => {
                console.error("Error setting up disconnect:", error);
            });
        
        // If we have a Firestore reference, also set up cleanup there
        if (playerRef && typeof playerRef.onDisconnect === 'function') {
            playerRef.onDisconnect().delete()
                .then(() => {
                    console.log("Firestore player cleanup configured");
                })
                .catch(error => {
                    console.error("Error setting up Firestore cleanup:", error);
                });
        } else if (playerRef) {
            // Manual cleanup if onDisconnect isn't available for Firestore
            // We'll use the presence system to detect and clean up
            console.log("Setting up manual cleanup via presence system");
            
            // Listen for presence changes to clean up disconnected players
            window.firebaseDB.ref('presence').on('child_removed', snapshot => {
                const disconnectedPlayerId = snapshot.key;
                
                // Clean up player missiles when they disconnect
                cleanupDisconnectedPlayerMissiles(disconnectedPlayerId);
                
                // Also clean up Firestore data
                if (db) {
                    db.collection("players").doc(disconnectedPlayerId).delete()
                        .then(() => {
                            console.log("Removed disconnected player from Firestore:", disconnectedPlayerId);
                        })
                        .catch(error => {
                            console.error("Error removing disconnected player:", error);
                        });
                }
            });
        }
    } catch (error) {
        console.error("Error setting up presence:", error);
    }
}

function updateOtherPlayer(playerId, playerData) {
  // Skip outdated updates for existing players
  if (otherPlayers[playerId] && 
      otherPlayers[playerId].lastUpdateTime && 
      playerData.lastUpdated?.toMillis && 
      otherPlayers[playerId].lastUpdateTime > playerData.lastUpdated?.toMillis()) {
    return;
  }

  // Don't create a missile if position data is missing or is at origin (0,0,0)
  if (!playerData.position || 
      (Math.abs(playerData.position.x) < 0.1 && 
       Math.abs(playerData.position.y) < 0.1 && 
       Math.abs(playerData.position.z) < 0.1)) {
    console.log("Skipping player with invalid position data:", playerId);
    return;
  }
  
  // Create player if doesn't exist
  if (!otherPlayers[playerId]) {
    console.log(`New player joined: ${playerData.name}`);
    
    // Create missile model for this player
    const otherMissile = createOtherPlayerMissile(playerData.color || "#5c5c5c");
    scene.add(otherMissile);

     // Make sure the missile is visible
     otherMissile.visible = true;
    
    otherPlayers[playerId] = {
      id: playerId,
      name: playerData.name,
      missile: otherMissile,
      lastPosition: new THREE.Vector3(),
      targetPosition: new THREE.Vector3(),
      direction: new THREE.Vector3(),
      targetDirection: new THREE.Vector3(),
      color: playerData.color,
      isAccelerating: playerData.isAccelerating || false,
      lastUpdateTime: playerData.lastUpdated?.toMillis() || Date.now()
    };
    
    // Add marker to minimap
    addOtherPlayerMinimapMarker(playerId, playerData.color);

     // Update the leaderboard to show the new player
     updateLeaderboard();
  }
  
  // Update player data
  const player = otherPlayers[playerId];
  player.name = playerData.name;
  player.lastUpdateTime = playerData.lastUpdated?.toMillis() || Date.now();

  // Update leaderboard stats if available
  if (playerData.targetsDestroyed !== undefined) {
    player.targetsDestroyed = playerData.targetsDestroyed;
    updateLeaderboard(); // Update leaderboard when kills change
  }
  
  if (playerData.roundsWon !== undefined) {
    player.roundsWon = playerData.roundsWon;
  }
  
  // Set target position and direction for smooth interpolation
  if (playerData.position) {
    player.targetPosition.set(
      playerData.position.x,
      playerData.position.y,
      playerData.position.z
    );
  }
  
  if (playerData.direction) {
    player.targetDirection.set(
      playerData.direction.x,
      playerData.direction.y,
      playerData.direction.z
    );
  }
  
  player.isAccelerating = playerData.isAccelerating || false;
}

function removeOtherPlayer(playerId) {
  const player = otherPlayers[playerId];
  if (!player) return;
  
  console.log(`Player left: ${player.name}`);
  
  // Remove missile from scene
  if (player.missile) {
    scene.remove(player.missile);
    disposeObject(player.missile);
  }
  
  // Remove minimap marker
  removeOtherPlayerMinimapMarker(playerId);
  
  // Delete player data
  delete otherPlayers[playerId];
}

// Create a missile model for other players
function createOtherPlayerMissile(color) {
  const otherMissile = new THREE.Group();
  
  // Create the main body (cylinder)
  const bodyGeometry = new THREE.CylinderGeometry(1, 1, 8, 16);
  const bodyMaterial = new THREE.MeshStandardMaterial({ 
      color: color,
      metalness: 0.3,
      roughness: 0.6
  });
  const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
  body.castShadow = false;
  otherMissile.add(body);
  
  // Create the nose cone (cone)
  const noseGeometry = new THREE.ConeGeometry(1, 3, 16);
  const noseMaterial = new THREE.MeshStandardMaterial({ color: 0x999999 });
  const nose = new THREE.Mesh(noseGeometry, noseMaterial);
  nose.position.y = 5.5;
  nose.castShadow = false;
  otherMissile.add(nose);

  // Create fins (simplified)
  const finGeometry = new THREE.BoxGeometry(0.2, 2, 3);
  const finMaterial = new THREE.MeshStandardMaterial({ color: 0x242424 });
  
  for (let i = 0; i < 4; i++) {
      const fin = new THREE.Mesh(finGeometry, finMaterial);
      fin.position.y = -3;
      fin.rotation.y = (Math.PI / 2) * i;
      fin.position.x = Math.sin((Math.PI / 2) * i) * 1.2;
      fin.position.z = Math.cos((Math.PI / 2) * i) * 1.2;
      otherMissile.add(fin);
  }
  
  otherMissile.rotation.x = Math.PI / 2; // Point forward
  
  return otherMissile;
}

function cleanupDisconnectedPlayerMissiles(playerId) {
    console.log(`Cleaning up missiles for disconnected player: ${playerId}`);
    
    // Check if the player had an active missile
    if (otherPlayers[playerId] && otherPlayers[playerId].missile) {
        const missile = otherPlayers[playerId].missile;
        
        // Create a small explosion effect where the missile was
        createExplosion(missile.position.clone(), false, false);
        
        // Remove the missile from the scene
        scene.remove(missile);
        disposeObject(missile);
        
        console.log(`Removed missile for disconnected player: ${playerId}`);
    }
    
    // Remove from otherPlayers object (this should also update minimap marker)
    removeOtherPlayer(playerId);
    
    // Update player count in UI to reflect the disconnection
    updatePlayerCountUI();
    
    // Update leaderboard to remove the disconnected player
    updateLeaderboard();
}
        
    function checkCollisions() {
        if (!gameActive || resetDelay > 0 || !missile.visible) return;

        if (typeof handleCrash.inProgress !== 'undefined' && handleCrash.inProgress) {
        handleCrash.inProgress = false;
    }
    
    // Check portal collisions first
    if (checkPortalCollisions()) {
        return; // Portal collision takes precedence
    }
            
            // Missile dimensions
            const missileLength = 7;
            const missileRadius = 0.8;
            
            // Check ground collision
            if (missile.position.y < missileRadius) {
                handleCrash();
                return;
            }
            
             // Calculate missile front and back points properly
              tempVec3.copy(missileDirection).multiplyScalar(missileLength/2);
            const missileForwardPoint = tempVec4.copy(missile.position).add(tempVec3);

            tempVec3.copy(missileDirection).multiplyScalar(-missileLength/2);
            const missileBackPoint = tempVec5.copy(missile.position).add(tempVec3);
    
       
    // Check building collisions with improved cylinder-shaped hitbox
    for (let i = 0; i < buildings.length; i++) {
        const building = buildings[i];

        const buildingHalfWidth = building.userData.width / 2;
        const buildingHalfHeight = building.userData.height / 2;
        
         // Reuse the same Box3 and Vector3 objects
         reusableVec1.set(
            building.position.x - buildingHalfWidth,
            building.position.y - buildingHalfHeight,
            building.position.z - buildingHalfWidth
        );
        reusableVec2.set(
            building.position.x + buildingHalfWidth,
            building.position.y + buildingHalfHeight, 
            building.position.z + buildingHalfWidth
        );
        reusableBox.setFromPoints([reusableVec1, reusableVec2]);
        
        // Check if any part of the missile cylinder is inside the building
        // We'll simplify this by checking a few points along the missile axis
        const checkPoints = 5;
        let collision = false;
        
        for (let j = 0; j <= checkPoints; j++) {
            const t = j / checkPoints;
            const checkPoint = new THREE.Vector3().lerpVectors(missileBackPoint, missileForwardPoint, t);
            
            // Only check if the point is within the approximate bounding box
            if (reusableBox.containsPoint(checkPoint)) {
                // Calculate precise distance from center line of missile
                const pointOnAxis = new THREE.Vector3().lerpVectors(
                    missile.position, 
                    checkPoint,
                    missileDirection.dot(checkPoint.clone().sub(missile.position))
                );
                const distFromAxis = checkPoint.distanceTo(pointOnAxis);
                
                // If distance is less than missile radius, we have a collision
                if (distFromAxis <= missileRadius + 0.2) { // small buffer
                    collision = true;
                    break;
                }
            }
        }
        
        if (collision) {
        // Get actual impact point using the collision point
        let impactPoint;
        let hitFace = -1;

        for (let j = 0; j <= checkPoints; j++) {
        const t = j / checkPoints;
        const checkPoint = new THREE.Vector3().lerpVectors(missileBackPoint, missileForwardPoint, t);
        
        if (reusableBox.containsPoint(checkPoint)) {
            impactPoint = checkPoint.clone();
            
            // Determine which face was hit
            const buildingHalfWidth = building.userData.width / 2;
            const buildingHalfHeight = building.userData.height / 2;
            
            // Calculate distance to each face from impact point
            const distToTop = Math.abs(impactPoint.y - (building.position.y + buildingHalfHeight));
            const distToBottom = Math.abs(impactPoint.y - (building.position.y - buildingHalfHeight));
            const distToFront = Math.abs(impactPoint.z - (building.position.z + buildingHalfWidth));
            const distToBack = Math.abs(impactPoint.z - (building.position.z - buildingHalfWidth));
            const distToLeft = Math.abs(impactPoint.x - (building.position.x - buildingHalfWidth));
            const distToRight = Math.abs(impactPoint.x - (building.position.x + buildingHalfWidth));
            
            // Find the closest face
            const minDist = Math.min(distToTop, distToBottom, distToFront, distToBack, distToLeft, distToRight);
            if (minDist === distToTop) hitFace = 0;
            else if (minDist === distToBottom) hitFace = 1;
            else if (minDist === distToFront) hitFace = 2;
            else if (minDist === distToBack) hitFace = 3;
            else if (minDist === distToLeft) hitFace = 4;
            else if (minDist === distToRight) hitFace = 5;
            
            break;
        }
    }
        
        // If we don't have an impact point, use missile position
        if (!impactPoint) {
            impactPoint = missile.position.clone();
        }
        
         // Check if it's a target
    if (building.userData.isTarget) {
        handleTargetHit(building, impactPoint); // Pass impact point
    } else {
        addBuildingDamage(building);
        // handle the crash
        handleCrash(impactPoint, false);
    }
    return;
}
}
}  
        
function handleCrash(impactPoint, createGroundScorch = true) {
    // Static flag implementation is causing the problem
    // Let's replace it with a more reliable approach
    
    // Only process if the missile is visible and resetDelay isn't active
    if (!missile.visible || resetDelay > 0) return;

    createExplosion(impactPoint || missile.position.clone(), true, createGroundScorch);
    playSound('crash');
    stopFlightSounds();
    stats.crashes++;
    finishFlight();
    
    // Set camera target and delay
    cameraTarget = missile.position.clone();
    resetDelay = 2.0; // Wait 2 seconds before resetting
    
    // Hide missile
    missile.visible = false;
}
        
function handleTargetHit(target, impactPoint) {
    // Ensure this is actually a target building
    if (!target || !target.userData || !target.userData.isTarget) return;
    
    createExplosion(impactPoint || target.position.clone(), true, false);
    playSound('target');
    stopFlightSounds();

    // Store target position before removal for ground scorch
    const targetPosition = target.position.clone();
    const buildingWidth = target.userData.width;
    
    // Set camera target and delay
    cameraTarget = targetPosition;
    resetDelay = 2.0; // Wait 2 seconds before resetting
    
    // Hide missile
    missile.visible = false;
    
    // Remove target from scene and arrays
    scene.remove(target);
    const targetIndex = buildings.indexOf(target);
    if (targetIndex > -1) {
        buildings.splice(targetIndex, 1);
    }
    
    const targetBuildingIndex = targetBuildings.indexOf(target);
    if (targetBuildingIndex > -1) {
        targetBuildings.splice(targetBuildingIndex, 1);
    }

    // Create scorch mark on ground
    const scorchPosition = new THREE.Vector3(targetPosition.x, -0.3, targetPosition.z);
    createScorchMark(scorchPosition, false);
    
    // Make it slightly larger than normal 
    const lastScorch = scorchMarks[scorchMarks.length - 1];
    if (lastScorch) {
    const scorchSize = buildingWidth * 1.2; // Slightly bigger than building base
    lastScorch.scale.set(scorchSize, scorchSize, 1);
    
    if (lastScorch.userData.emberEffect) {
        lastScorch.userData.emberEffect.scale.set(scorchSize * 0.8, scorchSize * 0.8, 1);
    }
    
    lastScorch.userData.isTargetHit = true;
    lastScorch.userData.smokeIntensity = 2.0;
}

    createSmokeColumn(scorchPosition, 20);

    // Update stats
    stats.targetsDestroyed++;
    stats.targetsRemaining--;

    // Update player stats
    playerStats.targetsDestroyed++;
    updatePlayerStats(); // Calculate new TPM

    const playerLeaderboardIndex = leaderboard.findIndex(entry => entry.id === playerStats.id);
    if (playerLeaderboardIndex !== -1) {
        leaderboard[playerLeaderboardIndex].targetsDestroyed = playerStats.targetsDestroyed;
    }
    
    // Also update Firebase with the new achievement!
    syncPlayerStatsToFirebase();
    
    // Update leaderboard immediately to show new TPM
    updateLeaderboard();
    
    // Add highlight effect to player entry
    setTimeout(() => {
        highlightPlayerInLeaderboard();
    }, 100);
    
    // Check if all targets are destroyed - THIS IS THE KEY PART WE NEED TO FIX
    if (stats.targetsRemaining <= 0) {
        console.log("All targets destroyed! Round complete.");
        
         // 1. Add a flag to prevent double counting
    if (!window.roundAlreadyWon) {
        window.roundAlreadyWon = true;
        
       
        
        // Show victory message
        showRoundVictoryMessage();
        
        // Sync to Firebase with the update flag to prevent second increment
        syncPlayerStatsToFirebase({ skipRoundIncrement: true });
    }
   
        // Show game over screen
        showGameOver();

              
        // IMPORTANT: Always set up the next round via timeout
        // Clear any existing timeout first to prevent multiple restarts
        if (window.gameOverTimeout) {
            clearTimeout(window.gameOverTimeout);
        }
        
        // Set timeout for new round
        window.gameOverTimeout = setTimeout(() => {
            console.log("Starting new round...");
            restartGame();
        }, 4000);
    }
    
    finishFlight();
}

function createPlayerMissileSmoke() {
    // Skip if we're at particle limit
    if (smokeParticles.length > MAX_SMOKE_PARTICLES * 0.9) return;
    
    const smokeSize = isAccelerating ? 0.5 : 0.3;
    const smokeGeometry = new THREE.SphereGeometry(smokeSize, 8, 8);
    
    // Use consistent gray color for smoke (matching enemy missiles)
    const smokeMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x555555,  // Gray color matching enemy missiles
        transparent: true,
        opacity: isAccelerating ? 0.6 : 0.4,
        depthWrite: false
    });
    
    const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
    
    // Position behind missile
    const missileBackVector = missileDirection.clone().negate();
    smoke.position.copy(missile.position)
        .add(missileBackVector.multiplyScalar(4.5))
        .add(new THREE.Vector3(
            THREE.MathUtils.randFloatSpread(0.3),
            THREE.MathUtils.randFloatSpread(0.3),
            THREE.MathUtils.randFloatSpread(0.3)
        ));
    
    // Smoke behavior - more dynamic when accelerating
    smoke.userData = {
        life: isAccelerating ? 1.2 : 0.8,
        maxLife: isAccelerating ? 1.2 : 0.8,
        growRate: isAccelerating ? 1.04 : 1.02,
        velocity: new THREE.Vector3(
            THREE.MathUtils.randFloatSpread(0.05),
            THREE.MathUtils.randFloat(isAccelerating ? 0.05 : 0.02, isAccelerating ? 0.15 : 0.08),
            THREE.MathUtils.randFloatSpread(0.05)
        )
    };
    
    scene.add(smoke);
    smokeParticles.push(smoke);
}
    
function updateOtherPlayers(delta) {
  const INTERPOLATION_SPEED = 5.0;
  
  Object.values(otherPlayers).forEach(player => {
    if (!player.missile) return;
    
    // Interpolate position for smooth movement
    player.lastPosition.lerp(player.targetPosition, delta * INTERPOLATION_SPEED);
    player.missile.position.copy(player.lastPosition);
    
    // Interpolate rotation
    player.direction.lerp(player.targetDirection, delta * INTERPOLATION_SPEED);

    // ADD THIS: Apply direction to missile orientation
    if (player.direction.lengthSq() > 0.5) {
      // Convert direction vector to quaternion rotation
      const missileRotation = new THREE.Quaternion().setFromUnitVectors(
        new THREE.Vector3(0, 1, 0),
        player.direction.clone().normalize()
      );
      player.missile.quaternion.copy(missileRotation);
    }
    
    // Track last movement with a timestamp
    if (!player.lastPositionUpdate) {
      player.lastPositionUpdate = Date.now();
      player.lastMovementPosition = player.lastPosition.clone();
    } else {
      // Check if the missile has moved significantly
      const movementThreshold = 0.1;
      if (player.lastMovementPosition.distanceTo(player.lastPosition) > movementThreshold) {
        player.lastPositionUpdate = Date.now();
        player.lastMovementPosition.copy(player.lastPosition);
      } else {
        // Check for timeout - remove missiles inactive for more than 10 seconds
        const inactiveTime = Date.now() - player.lastPositionUpdate;
        if (inactiveTime > 10000) { // 10 seconds
          console.log(`Removing stale missile for player: ${player.id || 'unknown'} - inactive for ${inactiveTime/1000}s`);
          removeOtherPlayer(player.id);
        }
      }
    }
  });
    
  // Update player count after potential removals
  updatePlayerCountUI();
}

function onPlayerAuthenticated() {
    // Set up player with random name and color 
    enhancePlayerInitialization();
    
    console.log("Player authenticated! ID:", playerStats.id);
    
    // Setup multiplayer sync
    setupMultiplayerSync();
    
    // Setup presence detection
    if (window.firebaseDB) {
        setupPlayerPresence();
    }
    
    // Initialize Agora and join channel
    initializeAgoraVoiceChat();
    createVoiceChatUI();
    
    // Give a small delay before joining the channel
    setTimeout(() => {
        joinAgoraChannel();
    }, 1000);
    
    // Update player count in UI
    updatePlayerCountUI();
}

function addOtherPlayerMinimapMarker(playerId, color) {
  // Skip if there's no minimap
  if (!minimapScene) return;
  
  // Create triangle marker similar to player marker
  const markerSize = 8;
  const triangleShape = new THREE.Shape();
  triangleShape.moveTo(0, -markerSize);
  triangleShape.lineTo(-markerSize * 0.6, markerSize * 0.5);
  triangleShape.lineTo(markerSize * 0.6, markerSize * 0.5);
  triangleShape.lineTo(0, -markerSize);
  
  const triangleGeometry = new THREE.ShapeGeometry(triangleShape);
  const markerMaterial = new THREE.MeshBasicMaterial({
    color: new THREE.Color(color || "#5c5c5c"),
    side: THREE.DoubleSide
  });
  
  const marker = new THREE.Mesh(triangleGeometry, markerMaterial);
  marker.rotation.x = Math.PI / 2; // Flat on XZ plane
  marker.position.y = 1.8; // Slightly above ground (below player marker)
  
  // Add to minimap
  minimapScene.add(marker);
  
  // Store reference
  if (!otherPlayers[playerId]) {
    otherPlayers[playerId] = {};
  }
  otherPlayers[playerId].minimapMarker = marker;
}

function updateOtherPlayerMinimapMarkers() {
  Object.values(otherPlayers).forEach(player => {
    if (!player.minimapMarker || !player.missile) return;
    
    // Update position
    player.minimapMarker.position.x = player.missile.position.x;
    player.minimapMarker.position.z = player.missile.position.z;
    
    // Update rotation if we have direction
    if (player.direction && player.direction.length() > 0.5) {
      const angle = Math.atan2(player.direction.x, -player.direction.z);
      player.minimapMarker.rotation.set(Math.PI / 2, 0, angle);
    }
  });
}

function removeOtherPlayerMinimapMarker(playerId) {
  const player = otherPlayers[playerId];
  if (!player || !player.minimapMarker) return;
  
  minimapScene.remove(player.minimapMarker);
  if (player.minimapMarker.geometry) player.minimapMarker.geometry.dispose();
  if (player.minimapMarker.material) player.minimapMarker.material.dispose();
  player.minimapMarker = null;
}

function updateOtherPlayerExhaust(player, delta) {
  // Skip if player has no missile
  if (!player.missile) return;
  
  // Find or create exhaust glow
  if (!player.exhaustGlow) {
    // Create a simple circle geometry for exhaust
    const glowGeometry = new THREE.CircleGeometry(0.8, 16);
    const glowMaterial = new THREE.MeshBasicMaterial({
      color: 0x555555, // Grey exhaust for all missiles
      transparent: true,
      opacity: 0.8,
      depthWrite: false
    });
    
    player.exhaustGlow = new THREE.Mesh(glowGeometry, glowMaterial);
    player.exhaustGlow.position.y = -6; // Position behind the exhaust
    player.exhaustGlow.rotation.x = Math.PI / 2; // Orient perpendicular to missile direction
    player.missile.add(player.exhaustGlow);
  }
  
  // Scale glow based on acceleration
  if (player.isAccelerating) {
    player.exhaustGlow.scale.set(1.5, 1.5, 1.5);
    player.exhaustGlow.material.opacity = 0.95;
  } else {
    player.exhaustGlow.scale.set(1.0, 1.0, 1.0);
    player.exhaustGlow.material.opacity = 0.8;
  }
  
  // Add subtle pulse effect
  const pulseAmount = 0.1 * Math.sin(Date.now() * 0.01);
  player.exhaustGlow.scale.x += pulseAmount;
  player.exhaustGlow.scale.y += pulseAmount;
}

// Add this function to create smoke particles for other players' missiles
function createOtherPlayerSmoke(player) {
  // Skip if we're at particle limit
  if (smokeParticles.length > MAX_SMOKE_PARTICLES * 0.9) return;
  
  // Create smoke particle
  const smokeSize = player.isAccelerating ? 0.5 : 0.3;
  const smokeGeometry = new THREE.SphereGeometry(smokeSize, 8, 8);
  
  const smokeMaterial = new THREE.MeshBasicMaterial({ 
    color: 0x555555, // Grey color for all exhaust smoke
    transparent: true,
    opacity: player.isAccelerating ? 0.6 : 0.4,
    depthWrite: false
  });
  
  const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
  
  // Get direction from missile orientation
  const missileDirection = new THREE.Vector3(0, 1, 0).applyQuaternion(player.missile.quaternion);
  
  // Position behind missile
  const missileBackVector = missileDirection.clone().negate();
  smoke.position.copy(player.missile.position)
    .add(missileBackVector.multiplyScalar(4.5))
    .add(new THREE.Vector3(
      THREE.MathUtils.randFloatSpread(0.3),
      THREE.MathUtils.randFloatSpread(0.3),
      THREE.MathUtils.randFloatSpread(0.3)
    ));
  
  // Smoke behavior
  smoke.userData = {
    life: player.isAccelerating ? 1.2 : 0.8,
    maxLife: player.isAccelerating ? 1.2 : 0.8,
    growRate: player.isAccelerating ? 1.04 : 1.02,
    velocity: new THREE.Vector3(
      THREE.MathUtils.randFloatSpread(0.05),
      THREE.MathUtils.randFloat(player.isAccelerating ? 0.05 : 0.02, player.isAccelerating ? 0.15 : 0.08),
      THREE.MathUtils.randFloatSpread(0.05)
    )
  };
  
  scene.add(smoke);
  smokeParticles.push(smoke);
}


function cleanupScorchMarks() {
    // Remove old scorch marks
    for (let i = scorchMarks.length - 1; i >= 0; i--) {
        const scorch = scorchMarks[i];
        const age = Date.now() - scorch.userData.creationTime;
        
        if (age > scorch.userData.flickerDuration) {
            if (scorch.userData.flickerInterval) {
                clearInterval(scorch.userData.flickerInterval);
            }
            if (scorch.userData.emberEffect) {
                disposeObject(scorch.userData.emberEffect);
            }
            disposeObject(scorch);
            scorchMarks.splice(i, 1);
        } else {
            // Update opacity based on age
            const lifePercent = age / scorch.userData.flickerDuration;
            if (lifePercent > 0.7) { // Start fading after 70% of lifetime
                // We don't need to update opacity here - the global timer does this
            }
        }
    }
}
        
        function finishFlight() {
            // Calculate flight time and update average
            const flightTime = (Date.now() - startTime) / 1000;
            flightTimes.push(flightTime);
            
            // Calculate average flight time
            let sum = 0;
            for (let i = 0; i < flightTimes.length; i++) {
                sum += flightTimes[i];
            }
            avgFlightTime = sum / flightTimes.length;
        }
        
    function showGameOver() {
    console.log("Showing game over screen!");
    
    // Make sure the game is inactive during transition
    gameActive = false;
    stopFlightSounds();
    
    // Cancel any existing animation frame
    if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
    }
    
    // Determine the winner for this round
    const winners = determineRoundWinner();
    
    // Get the text to display based on winner(s)
    let winnerText = '';
    if (!winners || winners.length === 0) {
        winnerText = "Round Complete!<br><span class='subtitle'>No targets destroyed</span>";
    } else {
        // Single winner (with our new code there should always be just one winner)
        const winner = winners[0];
        const isPlayer = winner.id === playerStats.id;
        
        // Calculate round duration in seconds - use a sensible default for very short rounds
        const roundDurationInSeconds = Math.max(10, elapsedTime / 1000);
        const formattedTime = roundDurationInSeconds.toFixed(2);
        
        winnerText = `
            <span style="color: ${winner.color}">${winner.name}</span> Wins!<br>
            <span class='subtitle'>${isPlayer ? "You" : winner.name} destroyed ${winner.targetsDestroyed} targets
            in ${formattedTime} seconds</span>
        `;
    }
    
    // Show game over screen with winner information
    document.getElementById('gameOverScreen').style.display = 'block';
    document.getElementById('hud').style.display = 'none';
    document.getElementById('minimap').style.display = 'none';
    
    document.getElementById('gameOverScreen').innerHTML = `
        <div class="corner-decoration top-left"></div>
        <div class="corner-decoration top-right"></div>
        <div class="corner-decoration bottom-left"></div>
        <div class="corner-decoration bottom-right"></div>
        
        <h2>${winnerText}</h2>
        <div class="mission-transition">Next mission starting...</div>
    `;
    
    // Add some CSS for the subtitle
    const style = document.createElement('style');
    style.textContent = `
        .subtitle {
            font-size: 0.7em;
            color: #aaaaaa;
        }
    `;
    document.head.appendChild(style);
    
    // Clear any existing game over timeout
    if (window.gameOverTimeout) {
        clearTimeout(window.gameOverTimeout);
    }
    
    // Automatically restart after 3 seconds
    window.gameOverTimeout = setTimeout(() => {
        console.log("Starting new mission...");
        restartGame();
    }, 4000);
}
        

        
// Update the restartGame function to preserve camera transition
function restartGame() {
    console.log("Restarting game...");
    
    // Clear any existing timeouts
    if (window.gameOverTimeout) {
        clearTimeout(window.gameOverTimeout);
        window.gameOverTimeout = null;
    }

    // Reset the game over triggered flag
    window.gameOverTriggered = false;

    window.roundAlreadyWon = false;

    // Reset player stats for the new round (keep roundsWon)
    playerStats.targetsDestroyed = 0;
    playerStats.crashes = 0;
    playerStats.totalPlayTimeSeconds = 0;
    
    // Reset enemy pilot stats for the new round (keep roundsWon)
    enemyPilotStats.forEach(pilot => {
        pilot.targetsDestroyed = 0;
        pilot.crashes = 0;
        pilot.totalPlayTimeSeconds = 0;
    });

    // Hide game over screen, show HUD and minimap
    document.getElementById('gameOverScreen').style.display = 'none';
    document.getElementById('hud').style.display = 'block';
    document.getElementById('minimap').style.display = 'block';
    createHudElements(); // Recreate HUD elements
    
    // Reset game state variables
    resetDelay = 0; // IMPORTANT: Reset the delay counter
    cameraTarget = null; // Clear any camera target
    
    stats.targetsRemaining = 0;
    stats.targetsDestroyed = 0;
    stats.crashes = 0;
    flightTimes = [];
    avgFlightTime = 0;

    // Clear damaged buildings array
    damagedBuildings = [];

    // Clear all smoke particles - including those from damaged buildings
    for (let i = smokeParticles.length - 1; i >= 0; i--) {
        const smoke = smokeParticles[i];
        // Check if this is building smoke
        if (smoke.userData && (smoke.userData.source === 'building' || smoke.userData.source === 'scorch')) {
            scene.remove(smoke);
            disposeObject(smoke);
            smokeParticles.splice(i, 1);
        }
    }

    // Remove all enemy missiles to ensure fair restart
    for (let i = enemyMissiles.length - 1; i >= 0; i--) {
        const enemyMissile = enemyMissiles[i];
        scene.remove(enemyMissile);
        disposeObject(enemyMissile);
    }
    enemyMissiles = [];
    enemyMissileTimer = 0; // Reset the timer so missiles don't spawn immediately
    
    // IMPORTANT FIX: Clean up other player missiles
    Object.keys(otherPlayers).forEach(playerId => {
        removeOtherPlayer(playerId);
    });
    
    // Clear old buildings
    for (let i = buildings.length - 1; i >= 0; i--) {
        disposeObject(buildings[i]);
    }
    buildings = [];
    targetBuildings = [];
    
    // Clear old scorch marks for the new level
    for (let i = scorchMarks.length - 1; i >= 0; i--) {
        const scorch = scorchMarks[i];
        if (scorch.userData.emberEffect) {
            disposeObject(scorch.userData.emberEffect);
        }
        disposeObject(scorch);
    }
    scorchMarks = [];

    initializeLeaderboard();
    
    // Create new city
    createCity();
    
    // Create new missile and set camera position
    missile.visible = false; // Make sure it's hidden before reset
    resetMissile();
    
    // Calculate exact camera position behind missile (no smoothing)
    const exactCameraPos = missile.position.clone().sub(
        missileDirection.clone().multiplyScalar(cameraOffset.z)
    );
    exactCameraPos.y += cameraOffset.y;
    
    // Calculate look target
    const exactLookTarget = missile.position.clone().add(
        missileDirection.clone().multiplyScalar(10)
    );
    
    // Set camera position directly
    camera.position.copy(exactCameraPos);
    smoothedCameraPosition.copy(exactCameraPos);
    smoothedCameraLookAt.copy(exactLookTarget);

    // Reset camera up vector to ensure it starts level
    camera.up.set(0, 1, 0);
    
    // Reset the vertical reference frame that's used during flight
    camera.userData.verticalReferenceFrame = {
        forward: new THREE.Vector3().copy(missileDirection).normalize(),
        right: new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), missileDirection).normalize(),
        up: new THREE.Vector3(0, 1, 0)
    };
    
       
    // Force camera to look at target immediately
    camera.lookAt(exactLookTarget);

     // Make missile visible
     missile.visible = true;
    
    // Activate the game
    gameActive = true;
    
    // Play sounds
    playSound('ui');
    playSound('missile');
    
    // Restart animation loop
    if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
    }
    lastTime = 0;
    animationFrameId = requestAnimationFrame(animate);
    
    console.log("Game restarted successfully!");
}
        
function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    if (isMobile) {
        scaleMobileUI();
    }
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    if (isMobile) {
        scaleMobileUI();
    }
}



        
        function onKeyDown(event) {
    // Convert event.code to key name in our object
    const key = event.code;
    if (key in keys) {
        keys[key] = true;
        
        if (key === 'Space') {
            isAccelerating = true;
            updateFlightSound(true);
        }
        
        // Prevent scrolling with arrow keys
        event.preventDefault();
    }
}
        
function onKeyUp(event) {
    const key = event.code;
    if (key in keys) {
        keys[key] = false;
        
        if (key === 'Space') {
            isAccelerating = false;
            updateFlightSound(false);
        }
    }
}
        
function handleDeviceOrientation(event) {
    if (!gameActive || !isMobile) return;
    
    // alpha: rotation around z-axis (0-360)
    // beta: front-back tilt (-180 to 180, front is positive)
    // gamma: left-right tilt (-90 to 90, right is positive)
    const alpha = event.alpha || 0;
    const beta = event.beta || 0;
    const gamma = event.gamma || 0;
    
    // Store initial orientation on first reading if not calibrated
    if (!window.hasOwnProperty('calibratedOrientation')) {
        window.calibratedOrientation = {
            alpha: alpha,
            beta: beta,
            gamma: gamma,
            initialized: true
        };
        
        // Create recalibrate button
        const calibrateBtn = document.createElement('button');
        calibrateBtn.innerHTML = '🔄 Calibrate';
        calibrateBtn.style.position = 'absolute';
        calibrateBtn.style.bottom = '10px';
        calibrateBtn.style.left = '10px';
        calibrateBtn.style.padding = '8px 12px';
        calibrateBtn.style.fontSize = '14px';
        calibrateBtn.style.backgroundColor = 'rgba(0,0,0,0.5)';
        calibrateBtn.style.color = 'white';
        calibrateBtn.style.border = 'none';
        calibrateBtn.style.borderRadius = '5px';
        calibrateBtn.style.zIndex = '2000';
        
        calibrateBtn.addEventListener('click', function() {
            // Recalibrate based on current orientation
            window.calibratedOrientation = {
                alpha: alpha,
                beta: beta,
                gamma: gamma,
                initialized: true
            };
            
            // Show feedback
            const feedback = document.createElement('div');
            feedback.textContent = 'Controls Calibrated!';
            feedback.style.position = 'absolute';
            feedback.style.top = '50%';
            feedback.style.left = '50%';
            feedback.style.transform = 'translate(-50%, -50%)';
            feedback.style.backgroundColor = 'rgba(0,0,0,0.7)';
            feedback.style.color = 'white';
            feedback.style.padding = '10px 20px';
            feedback.style.borderRadius = '5px';
            feedback.style.zIndex = '2001';
            document.body.appendChild(feedback);
            
            setTimeout(() => {
                document.body.removeChild(feedback);
            }, 2000);
        });
        
        document.body.appendChild(calibrateBtn);
    }
    
    // Calculate relative orientation based on calibrated values
    const relBeta = beta - window.calibratedOrientation.beta;
    const relGamma = gamma - window.calibratedOrientation.gamma;
    
    // Map the orientation to missile controls:
    
    // 1. Left/Right turns (gamma)
    // When device is tilted left/right, turn missile
    // -30 to +30 degrees for full turn
    const yawInput = clamp(relGamma / 30, -1, 1);
    
    // 2. Up/Down controls (beta)
    // Device facing up = missile down, device facing down = missile up
    // We want neutral to be perpendicular to ground (beta = 90)
    const pitchOffset = 90 - beta;
    const pitchInput = clamp(pitchOffset / 30, -1, 1);
    
    // Apply to missile controls
    keys.ArrowLeft = yawInput < -0.15;
    keys.ArrowRight = yawInput > 0.15;
    keys.ArrowUp = pitchInput > 0.15;
    keys.ArrowDown = pitchInput < -0.15;
    
    // For more precise analog controls, store the actual values too
    missile.userData.mobileControls = {
        yawInput: yawInput,
        pitchInput: pitchInput
    };
}

// Helper function to clamp values
function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}

// Update the updateMissile function to use analog controls on mobile
function updateMissileForMobile() {
    // Add this code in your updateMissile function
    
    // Get input values - on mobile, use analog values for smoother control
    let pitchInput, yawInput;
    
    if (isMobile && missile.userData.mobileControls) {
        // Use analog values from mobile
        pitchInput = -missile.userData.mobileControls.pitchInput;
        yawInput = missile.userData.mobileControls.yawInput;
    } else {
        // Use keyboard controls (digital)
        pitchInput = (keys.ArrowUp ? -1 : 0) + (keys.ArrowDown ? 1 : 0);
        yawInput = (keys.ArrowLeft ? 1 : 0) + (keys.ArrowRight ? -1 : 0);
    }
    
    // Apply to turn velocity with damping
    turnVelocity.x = turnVelocity.x * damping + (pitchInput * turnSpeed) * (1 - damping);
    turnVelocity.y = turnVelocity.y * damping + (yawInput * turnSpeed) * (1 - damping);
}
    
    function updateMissile(delta) {
    if (!gameActive) return;

    const dt = delta;

    // Apply acceleration/deceleration
    if (isAccelerating) {
        velocity = Math.min(velocity + acceleration * dt, maxVelocity);
    } else {
        velocity = Math.max(velocity - acceleration * dt * 0.6, baseVelocity);
    }

    // Update smoke trail with variable rate based on acceleration
    playerSmokeTimer -= delta;
    if (playerSmokeTimer <= 0) {
        // Emit smoke more frequently when accelerating
        playerSmokeTimer = isAccelerating ? 0.03 : 0.06;
        
        // Only create smoke if missile is visible and game is active
        if (missile.visible && gameActive && !launchAnimation && resetDelay <= 0) {
            createPlayerMissileSmoke();
        }
    }
    
    // Get input values
    const pitchInput = (keys.ArrowUp ? -1 : 0) + (keys.ArrowDown ? 1 : 0);
    const yawInput = (keys.ArrowLeft ? 1 : 0) + (keys.ArrowRight ? -1 : 0);
    const rollInput = (keys.KeyQ ? 1 : 0) + (keys.KeyE ? -1 : 0);

    // Calculate control rates with damping
    turnVelocity.x = turnVelocity.x * damping + (pitchInput * turnSpeed) * (1 - damping);
    turnVelocity.y = turnVelocity.y * damping + (yawInput * turnSpeed) * (1 - damping);
    turnVelocity.z = turnVelocity.z * damping + (rollInput * turnSpeed * 1.5) * (1 - damping);
    
    // Define our reference axes based on current missile orientation
    // Forward is always the missile's current direction
    const forward = missileDirection.clone();
    
    // Get the world up vector
    const worldUp = new THREE.Vector3(0, 1, 0);
    
    // Calculate missile's right vector using world up as a reference
    // This ensures we always have a stable reference frame
    const right = new THREE.Vector3().crossVectors(forward, worldUp).normalize();
    
    // If we're close to vertical, right might be very small, so handle that case
    if (right.lengthSq() < 0.01) {
        // In near-vertical alignment, use a fixed horizontal reference
        right.set(1, 0, 0);
    }
    
    // Calculate missile's local up vector from right and forward
    const up = new THREE.Vector3().crossVectors(right, forward).normalize();
    
    // Apply pitch (rotate around right vector)
    const pitchQuat = new THREE.Quaternion().setFromAxisAngle(
        right, turnVelocity.x * dt * 60
    );
    
    // Apply yaw (rotate around up vector)
    const yawQuat = new THREE.Quaternion().setFromAxisAngle(
        up, turnVelocity.y * dt * 60
    );
    
    // Apply roll (rotate around forward vector)
    const rollQuat = new THREE.Quaternion().setFromAxisAngle(
        forward, turnVelocity.z * dt * 60
    );
    
    // Combine all rotations
    const combinedQuat = new THREE.Quaternion().multiply(yawQuat).multiply(pitchQuat);
    
    // Apply to missile direction
    missileDirection.applyQuaternion(combinedQuat);
    missileDirection.normalize();
    
    // Calculate final missile orientation
    const baseOrientation = new THREE.Quaternion().setFromUnitVectors(
        new THREE.Vector3(0, 1, 0), missileDirection
    );
    
    // Apply roll separately to the visual model
    missile.quaternion.copy(baseOrientation).multiply(rollQuat);
    
    // Update exhaust
    updateMissileExhaust();
}

function createScorchMark(position, isOnBuilding = false) {
    // Limit total scorch marks
    if (scorchMarks.length > 75) {
        const oldestScorch = scorchMarks.shift();
        if (oldestScorch.userData.emberEffect) {
            disposeObject(oldestScorch.userData.emberEffect);
        }
        disposeObject(oldestScorch);
    }
    
    // Create star-shaped scorch texture if it doesn't exist
    if (!window.scorchTexture) {
        // [Keep existing star-shaped scorch texture creation code]
        const canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 256;
        const ctx = canvas.getContext('2d');
        
        // Center point
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const outerRadius = canvas.width * 0.45;
        const innerRadius = outerRadius * 0.4;
        
        ctx.beginPath();
        const points = 16;
        const jaggedPoints = 3;
        let firstPoint = true;
        
        for (let i = 0; i < points; i++) {
            const mainAngle = (Math.PI * 2 * i) / points;
            
            for (let j = 0; j <= jaggedPoints; j++) {
                const subAngle = mainAngle + (Math.PI * 2 / points) * (j / jaggedPoints);
                
                const flareChance = Math.random();
                const radiusMult = flareChance < 0.2 ? 
                    1.3 + Math.random() * 0.4 : 
                    0.7 + Math.random() * 0.6;
                    
                const radius = innerRadius + (outerRadius - innerRadius) * radiusMult;
                
                const x = centerX + Math.cos(subAngle) * radius;
                const y = centerY + Math.sin(subAngle) * radius;
                
                if (firstPoint) {
                    ctx.moveTo(x, y);
                    firstPoint = false;
                } else {
                    ctx.lineTo(x, y);
                }
            }
        }
        
        ctx.closePath();
        
        const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, outerRadius);
        gradient.addColorStop(0, 'rgba(0, 0, 0, 0.95)');
        gradient.addColorStop(0.4, 'rgba(20, 20, 20, 0.85)');
        gradient.addColorStop(0.7, 'rgba(30, 30, 30, 0.7)');
        gradient.addColorStop(0.9, 'rgba(40, 40, 40, 0.3)');
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        ctx.fillStyle = gradient;
        ctx.fill();
        
        ctx.globalCompositeOperation = 'source-atop';
        for (let i = 0; i < 800; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const radius = Math.random() * 2 + 0.5;
            const opacity = Math.random() * 0.3;
            
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(0, 0, 0, ${opacity})`;
            ctx.fill();
        }
        
        window.scorchTexture = new THREE.CanvasTexture(canvas);
        window.scorchTexture.minFilter = THREE.LinearFilter;
    }
    
    // Create ember texture if needed
    if (!window.emberTexture) {
        // [Keep existing ember texture creation code]
        const emberCanvas = document.createElement('canvas');
        emberCanvas.width = 256;
        emberCanvas.height = 256;
        const emberCtx = emberCanvas.getContext('2d');
        
        const centerX = emberCanvas.width / 2;
        const centerY = emberCanvas.height / 2;
        const outerRadius = emberCanvas.width * 0.4;
        const innerRadius = outerRadius * 0.5;
        
        emberCtx.beginPath();
        const starPoints = 12;
        
        for (let i = 0; i < starPoints * 2; i++) {
            const angle = (Math.PI * 2 * i) / (starPoints * 2);
            const radius = i % 2 === 0 ? outerRadius : innerRadius;
            
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;
            
            if (i === 0) emberCtx.moveTo(x, y);
            else emberCtx.lineTo(x, y);
        }
        
        emberCtx.closePath();
        
        const emberGradient = emberCtx.createRadialGradient(
            centerX, centerY, 0, centerX, centerY, outerRadius);
        emberGradient.addColorStop(0, 'rgba(255, 160, 30, 0.8)');
        emberGradient.addColorStop(0.4, 'rgba(255, 80, 0, 0.5)');
        emberGradient.addColorStop(0.7, 'rgba(255, 30, 0, 0.2)');
        emberGradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
        
        emberCtx.fillStyle = emberGradient;
        emberCtx.fill();
        
        window.emberTexture = new THREE.CanvasTexture(emberCanvas);
        window.emberTexture.minFilter = THREE.LinearFilter;
    }
    
    // Create scorch mark using existing meshes
    const scorchSize = isOnBuilding ? 3.0 : 8.0;
    const scorchGeometry = new THREE.PlaneGeometry(scorchSize, scorchSize);
    
    const scorchMaterial = new THREE.MeshBasicMaterial({
        map: window.scorchTexture,
        transparent: true,
        depthWrite: false,
        side: THREE.DoubleSide
    });
    
    const scorchMark = new THREE.Mesh(scorchGeometry, scorchMaterial);
    scorchMark.position.copy(position);
    
    if (!isOnBuilding) {
        scorchMark.rotation.x = -Math.PI / 2;
        scorchMark.position.y = 0.01;
    }
    
    // Add random rotation for variety
    scorchMark.rotation.z = Math.random() * Math.PI * 2;
    
    // Add ember effect
    const emberGeometry = new THREE.PlaneGeometry(scorchSize * 0.7, scorchSize * 0.7);
    const emberMaterial = new THREE.MeshBasicMaterial({
        map: window.emberTexture, 
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        side: THREE.DoubleSide
    });
    
    const emberEffect = new THREE.Mesh(emberGeometry, emberMaterial);
    emberEffect.position.copy(scorchMark.position);
    emberEffect.rotation.copy(scorchMark.rotation);
    emberEffect.position.y += 0.01;
    emberEffect.rotation.z = scorchMark.rotation.z;
    
    scene.add(scorchMark);
    scene.add(emberEffect);
    
    scorchMark.userData.emberEffect = emberEffect;
    
    // Set longer duration and higher smoke intensity for target hits
    const isTargetHit = !isOnBuilding && position.y < 1.0; // Ground scorch from target hit
    const flickerDuration = 300000; // 5 minutes
    const smokeIntensity = isTargetHit ? 2.0 : (isOnBuilding ? 0.8 : 1.2);
    
    // Configure scorch mark properties
    scorchMark.userData = {
        creationTime: Date.now(),
        flickerDuration: flickerDuration,
        emberEffect: emberEffect,
        smokeEnabled: true,
        smokeTimer: 0,
        smokeIntensity: smokeIntensity,
        isTargetHit: isTargetHit
    };
    
    scorchMarks.push(scorchMark);
    
    // Start global timer if not running
    if (!globalScorchTimer) {
        startGlobalScorchTimer();
    }
    
    return scorchMark;
}


function createExplosionTexture() {
    // Create a single shared texture for all explosion particles
    if (!window.explosionTexture) {
        // Create the explosion texture procedurally
        const canvas = document.createElement('canvas');
        canvas.width = 128;
        canvas.height = 128;
        const ctx = canvas.getContext('2d');
        
        // Create multi-colored explosion gradient
        const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
        gradient.addColorStop(0, 'rgba(255, 255, 220, 1.0)');    // Bright center
        gradient.addColorStop(0.2, 'rgba(255, 200, 70, 0.9)');   // Yellow-orange
        gradient.addColorStop(0.4, 'rgba(255, 60, 20, 0.8)');    // Red-orange
        gradient.addColorStop(0.7, 'rgba(150, 20, 10, 0.5)');    // Dark red
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');           // Transparent edge
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 128, 128);
        
        window.explosionTexture = new THREE.CanvasTexture(canvas);
    }
    
    // Create a simple plane that will always face the camera
    const explosionGeometry = new THREE.PlaneGeometry(1, 1);
    const explosionMaterial = new THREE.MeshBasicMaterial({
        map: window.explosionTexture,
        transparent: true,
        blending: THREE.AdditiveBlending,  // Additive blending for glow effect
        depthWrite: false,
        side: THREE.DoubleSide
    });
    
    return { geometry: explosionGeometry, material: explosionMaterial };
}



function updateCamera(delta) {
    if (!missile.visible || !camera) return;

    ensureCameraReferences();
    
    // Calculate target camera position
    const targetCameraPos = missile.position.clone().sub(
        missileDirection.clone().multiplyScalar(cameraOffset.z)
    );
    targetCameraPos.y += cameraOffset.y;
    
    const lookTarget = missile.position.clone().add(
        missileDirection.clone().multiplyScalar(10)
    );
    
    // Smooth movement
    smoothedCameraPosition.lerp(targetCameraPos, cameraSmoothingFactor);
    smoothedCameraLookAt.lerp(lookTarget, cameraSmoothingFactor);
    
    // Update camera position
    camera.position.copy(smoothedCameraPosition);
    
    // IMPORTANT: Create verticalReferenceFrame if it doesn't exist
    // This is the code that was causing the error
    if (!camera.userData) camera.userData = {};
    if (!camera.userData.verticalReferenceFrame) {
        camera.userData.verticalReferenceFrame = {
            forward: new THREE.Vector3().copy(missileDirection).normalize(),
            right: new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), missileDirection).normalize(),
            up: new THREE.Vector3(0, 1, 0)
        };
    }
    
    // Add additional safety check for the up vector
    if (!camera.userData.verticalReferenceFrame.up) {
        camera.userData.verticalReferenceFrame.up = new THREE.Vector3(0, 1, 0);
    }
    
    // Get world up and check vertical alignment
    const worldUp = new THREE.Vector3(0, 1, 0);
    const verticalAlignment = missileDirection.dot(worldUp);
    const isNearVertical = Math.abs(verticalAlignment) > 0.95;
    
    // Use optional chaining for additional safety
    if (isNearVertical && camera.userData?.verticalReferenceFrame?.up) {
        camera.up.copy(camera.userData.verticalReferenceFrame.up);
    } else {
        // Use the default world up when not near vertical or if reference frame is missing
        camera.up.set(0, 1, 0);
    }
    
    camera.lookAt(smoothedCameraLookAt);
}
        
function updateMinimap() {
    if (!gameActive) return;
    
    // Always rotate the container with fixed rotation
    if (minimapContainer && typeof minimapFixedRotation !== 'undefined') {
        minimapContainer.style.transform = `rotate(${-minimapFixedRotation}rad)`;
    }
    
    // Update player marker position and rotation using THREE.js
    if (playerMarker && missile && missile.position && missileDirection) {
        // Update position to match actual missile position
        playerMarker.position.x = missile.position.x;
        playerMarker.position.z = missile.position.z;
        
        // Update rotation
        const angle = Math.atan2(missileDirection.x, -missileDirection.z);
        playerMarker.rotation.set(Math.PI / 2, 0, angle);
    }
    
    // Update and render
    updateMinimapBuildings();
    updateEnemyMinimapMarkers();
    
    // Render the minimap scene
    if (minimapRenderer && minimapScene && minimapCamera) {
        minimapRenderer.render(minimapScene, minimapCamera);
    }
}

    // Function to update building representations in minimap
    function updateMinimapBuildings() {
    // Hide all dots from previous frame
    minimapBuildingDots.forEach(dot => {
        minimapScene.remove(dot);
    });
    
    minimapBuildingDots = [];
    
    // Add buildings to the minimap
    buildings.forEach(building => {
        // Create or reuse a dot for this building
        let dot;
        
        if (building.userData.isTarget) {
            // For target buildings (red)
            dot = window.minimapDotPool.target.pop() || 
                  new THREE.Mesh(window.minimapDotPool.geometryTarget, window.minimapDotPool.materialTarget);
        } else {
            // For regular buildings (white)
            dot = window.minimapDotPool.regular.pop() || 
                  new THREE.Mesh(window.minimapDotPool.geometryRegular, window.minimapDotPool.materialRegular);
        }
        
        // Position dot on minimap
        dot.position.set(building.position.x, 1, building.position.z);

         // Keep it flat (facing upward)
         dot.rotation.x = -Math.PI / 2;
        
        minimapScene.add(dot);
        minimapBuildingDots.push(dot);
    });
}


function createEnemyMissile() {
    // Choose random edge of map to spawn from
    const spawnIndex = Math.floor(Math.random() * spawnPoints.length);
    const spawnPosition = spawnPoints[spawnIndex].clone();
    
    // Small random variation in spawn position
    spawnPosition.x += THREE.MathUtils.randFloatSpread(100);
    spawnPosition.z += THREE.MathUtils.randFloatSpread(100);
    spawnPosition.y = THREE.MathUtils.randFloat(80, 120);
    
    // Create enemy missile
    const enemyMissile = new THREE.Group();
    
    // Body (slightly different from player's missile)
    const bodyGeometry = new THREE.CylinderGeometry(0.8, 0.8, 7, 16);
    
    // Assign a specific pilot to this missile
    const pilotIndex = Math.floor(Math.random() * enemyPilotStats.length);
    const pilot = enemyPilotStats[pilotIndex];

        
    // Use pilot's color if available
    const missileColor = pilot.color || new THREE.Color(
        0.3 + Math.random() * 0.7, 
        0.3 + Math.random() * 0.7, 
        0.3 + Math.random() * 0.7
    ).getHex();
    
    // Convert hex to string format if needed
    const colorStr = typeof missileColor === 'number' ? 
        '#' + missileColor.toString(16).padStart(6, '0') : missileColor;
    
    // Store pilot color if not already set
    if (!pilot.color) {
        pilot.color = colorStr;
    }
    
    const bodyMaterial = new THREE.MeshStandardMaterial({ 
        color: colorStr,
        metalness: 0.3,
        roughness: 0.6
    });
    
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.castShadow = false;
    enemyMissile.add(body);
    
    // Nose cone
    const noseGeometry = new THREE.ConeGeometry(0.8, 2.5, 16);
    const noseMaterial = new THREE.MeshStandardMaterial({ color: 0x999999 });
    const nose = new THREE.Mesh(noseGeometry, noseMaterial);
    nose.position.y = 4.5;
    nose.castShadow = false;
    enemyMissile.add(nose);
    
    // Fins
    const finGeometry = new THREE.BoxGeometry(0.2, 1.5, 2.5);
    const finMaterial = new THREE.MeshStandardMaterial({ color: 0x242424 });
    
    for (let i = 0; i < 4; i++) {
        const fin = new THREE.Mesh(finGeometry, finMaterial);
        fin.position.y = -2.5;
        fin.castShadow = false;
        
        // Position fins around the missile
        fin.rotation.y = (Math.PI / 2) * i;
        fin.position.x = Math.sin((Math.PI / 2) * i) * 1.0;
        fin.position.z = Math.cos((Math.PI / 2) * i) * 1.0;
        
        enemyMissile.add(fin);
    }
    
    // Add missile to scene
    enemyMissile.rotation.x = Math.PI / 2; // Point forward
    enemyMissile.position.copy(spawnPosition);
    scene.add(enemyMissile);
    
    // Choose target building - prioritize target buildings
    let targetBuilding;
    if (targetBuildings.length > 0) {
        // 70% chance to target a red target building
        if (Math.random() < 0.7) {
            targetBuilding = targetBuildings[Math.floor(Math.random() * targetBuildings.length)];
        } else if (buildings.length > 0) {
            targetBuilding = buildings[Math.floor(Math.random() * buildings.length)];
        }
    } else if (buildings.length > 0) {
        targetBuilding = buildings[Math.floor(Math.random() * buildings.length)];
    }
    
    // Set target position and direction
    let targetPosition;
    if (targetBuilding) {
        targetPosition = targetBuilding.position.clone();
        // Aim for the middle of the building
        targetPosition.y = targetBuilding.userData.height / 2;
    } else {
        // Fallback to city center with some randomization
        targetPosition = new THREE.Vector3(
            THREE.MathUtils.randFloatSpread(citySize * 0.5),
            0,
            THREE.MathUtils.randFloatSpread(citySize * 0.5)
        );
    }
    
    // Calculate initial direction
    const direction = new THREE.Vector3()
        .subVectors(targetPosition, spawnPosition)
        .normalize();
    
    // Determine flight style based on target position and pilot skill
    // Deeper targets and more skilled pilots will use more advanced techniques
    const distanceToTarget = spawnPosition.distanceTo(targetPosition);
    const useAdvancedNavigation = distanceToTarget > citySize * 0.4 || Math.random() < 0.7;
        
    // Calculate piloting skill - better pilots use more evasive maneuvers
    const pilotSkillLevel = 0.5 + Math.random() * 0.5; // 0.5 to 1.0
    const isAggressive = Math.random() < 0.7; // 70% chance to be aggressive
    const preferHighAltitude = Math.random() < 0.4; // Reduced from 0.6 - fewer missiles taking the high path
    
    // Save properties with enhanced navigation data
    enemyMissile.userData = {
        direction: direction,
        originalDirection: direction.clone(), // Store for return to course
        speedModifiers: {
            direct: 1.0,
            climbing: 0.9,
            diving: 1.3, // Faster when diving
            weaving: 1.1 // Slightly faster when weaving
        },
        smokeTimer: 0,
        pathfindingTimer: 0,
        targetPosition: targetPosition,
        targetBuilding: targetBuilding,
        guidanceAccuracy: THREE.MathUtils.randFloat(0.9, 0.98),
        pilotId: pilot.id,
        pilotName: pilot.name,
        // Enhanced navigation properties
        useAdvancedNavigation: true,
        preferHighAltitude: preferHighAltitude,
        pilotSkillLevel: pilotSkillLevel,
        isAggressive: isAggressive,
        navigationState: 'direct', // Options: 'direct', 'climbing', 'diving', 'weaving'
        obstacleAvoidanceVector: null,
        reactionTime: 0.3 - (pilotSkillLevel * 0.2),
        weaveDirection: Math.random() > 0.5 ? 1 : -1, // Random initial weave direction
        idealAltitude: Math.random() * 80 + 100, // Random altitude between 120-220
        hasPlannedPath: false,
        pathPoints: [],
        currentPathIndex: 0
    };
    
    // Align missile with direction
    const missileRotation = new THREE.Quaternion().setFromUnitVectors(
        new THREE.Vector3(0, 1, 0), 
        direction
    );
    enemyMissile.quaternion.copy(missileRotation);
    
    // Add to enemy missiles array
    enemyMissiles.push(enemyMissile);
}

// Update enemy missiles
function updateEnemyMissiles(delta) {
    // Update missile timer
    enemyMissileTimer += delta;
    
    // Spawn new enemy missiles if we're under the limit
    if (enemyMissileTimer > enemyMissileSpawnRate && enemyMissiles.length < maxEnemyMissiles && gameActive) {
        enemyMissileTimer = 0;
        createEnemyMissile();
    }
    
    // Reuse the same raycaster for all missiles
    const raycaster = new THREE.Raycaster();
    
    // Update existing enemy missiles
    for (let i = enemyMissiles.length - 1; i >= 0; i--) {
        const enemyMissile = enemyMissiles[i];
        if (!enemyMissile) continue;
        
        // Skip if missile is not visible
        if (!enemyMissile.visible) continue;
        
        // --- IMPROVED TARGETING LOGIC STARTS HERE ---
        
        // Get current properties
        const currentPos = enemyMissile.position;
        const currentDir = enemyMissile.userData.direction;
        const targetPos = enemyMissile.userData.targetPosition;
        const targetBuilding = enemyMissile.userData.targetBuilding;
        
        // Recalculate target position if we have a target building and it still exists
        if (targetBuilding && targetBuilding.visible) {
            enemyMissile.userData.targetPosition = targetBuilding.position.clone();
            enemyMissile.userData.targetPosition.y = targetBuilding.userData.height / 2;
        }
        
        // Calculate distance to target
        const distToTarget = currentPos.distanceTo(targetPos);
        
        // Calculate ideal direction to target
        const idealDirection = new THREE.Vector3()
            .subVectors(targetPos, currentPos)
            .normalize();
        
        // Calculate missile speed - more aggressive when close to target
        enemyMissile.userData.speed = distToTarget < 100 
            ? enemyMissileMaxSpeed * 1.1  // 10% faster when close to target
            : enemyMissileMaxSpeed;
        
        // Improved targeting logic - higher priority on target
        
        // 1. Base target seeking force - INCREASED WEIGHT
        const targetWeight = distToTarget < 150 ? 0.8 : 0.5; // Higher weight when closer to target
        const targetForce = idealDirection.clone();
        
        // 2. Obstacle avoidance with REDUCED WEIGHT
        const avoidWeight = distToTarget < 100 ? 0.3 : 0.5; // Lower weight when closer to target
        const avoidanceForce = new THREE.Vector3();
        
        // Only check for obstacles if we're not close to target
        if (distToTarget > 30) {
            // Set up obstacle detection
            raycaster.set(currentPos, currentDir);
            raycaster.far = Math.min(100, distToTarget); // Don't look past the target
            
            const intersects = raycaster.intersectObjects(buildings);
            
            if (intersects.length > 0) {
                const obstacle = intersects[0];
                
                // Skip avoidance for target buildings when close
                if (obstacle.object === targetBuilding && distToTarget < 80) {
                    // Do nothing - we want to hit it!
                } else {
                    // Calculate avoidance vector - points away from obstacle
                    const obstaclePos = obstacle.point;
                    const obstacleDir = new THREE.Vector3()
                        .subVectors(obstaclePos, currentPos)
                        .normalize();
                    
                    // Create perpendicular avoidance vector
                    avoidanceForce.crossVectors(obstacleDir, new THREE.Vector3(0, 1, 0))
                        .normalize();
                    
                    // Add slight upward component for safer avoidance
                    avoidanceForce.y = 0.3;
                    avoidanceForce.normalize();
                    
                    // Scale by inverse distance (closer = stronger)
                    const avoidanceStrength = 1.0 - (obstacle.distance / 100);
                    avoidanceForce.multiplyScalar(avoidanceStrength);
                }
            }
        }
        
        // 3. Calculate final steering force
        const steerForce = new THREE.Vector3();
        steerForce.addScaledVector(targetForce, targetWeight);
        steerForce.addScaledVector(avoidanceForce, avoidWeight);
        steerForce.normalize();
        
        // 4. Apply steering - more responsive when close to target
        const turnRate = distToTarget < 80 ? 0.15 : 0.08;
        enemyMissile.userData.direction.lerp(steerForce, turnRate).normalize();
        
        // --- END OF IMPROVED TARGETING LOGIC ---
        
        // Align missile with direction
        const missileRotation = new THREE.Quaternion().setFromUnitVectors(
            new THREE.Vector3(0, 1, 0), 
            enemyMissile.userData.direction
        );
        enemyMissile.quaternion.copy(missileRotation);
        
        // Update position
        const speed = enemyMissile.userData.speed * delta;
        enemyMissile.position.add(
            enemyMissile.userData.direction.clone().multiplyScalar(speed)
        );
        
        // Check for collision with ground
        if (enemyMissile.position.y < 0.5) {
            // Create explosion at impact
            createExplosion(enemyMissile.position.clone(), true);
            createScorchMark(enemyMissile.position.clone());
            
            // Remove missile
            scene.remove(enemyMissile);
            disposeObject(enemyMissile);
            enemyMissiles.splice(i, 1);
            continue;
        }
        
        // Check building collisions (existing code)
        let buildingCollision = false;
        for (let j = 0; j < buildings.length; j++) {
            const building = buildings[j];
            const buildingHalfWidth = building.userData.width / 2;
            const buildingHeight = building.userData.height;
            
            // Simple box collision check
            if (enemyMissile.position.x > building.position.x - buildingHalfWidth &&
                enemyMissile.position.x < building.position.x + buildingHalfWidth &&
                enemyMissile.position.z > building.position.z - buildingHalfWidth &&
                enemyMissile.position.z < building.position.z + buildingHalfWidth &&
                enemyMissile.position.y < building.position.y + buildingHeight &&
                enemyMissile.position.y > building.position.y) {
                
                // Set collision flag
                buildingCollision = true;
                
                // Create explosion at impact point
                const impactPoint = enemyMissile.position.clone();
                createExplosion(impactPoint, true, false);
                
                // If it's a target building, destroy it
                if (building.userData.isTarget) {
                    handleEnemyTargetHit(building);
                    
                    // Update pilot stats for the enemy that hit the target
                    if (enemyMissile.userData.pilotId) {
                        const pilot = enemyPilotStats.find(p => p.id === enemyMissile.userData.pilotId);
                        if (pilot) {
                            pilot.targetsDestroyed++;
                            updateEnemyPilotStats(pilot);
                        }
                    }
                } else {
                    // Regular building - just add damage for smoke effects
                    addBuildingDamage(building);
                }
                
                break; // Stop checking other buildings
            }
        }
        
        // Rest of existing code (collision handling, smoke trails, etc.)
        if (buildingCollision) {
            scene.remove(enemyMissile);
            disposeObject(enemyMissile);
            enemyMissiles.splice(i, 1);
            continue;
        }
        
        // Create smoke trail
        enemyMissile.userData.smokeTimer -= delta;
        if (enemyMissile.userData.smokeTimer <= 0) {
            enemyMissile.userData.smokeTimer = 0.05; // Emit smoke every 50ms
            createEnemyMissileSmoke(enemyMissile);
        }
    }
}

// New function to handle advanced navigation for enemy missiles
function updateMissileNavigation(enemyMissile, raycaster) {
    if (!enemyMissile.userData) return;
    
    // NEW: Apply appropriate speed modifier based on navigation state
    const speedModifiers = enemyMissile.userData.speedModifiers || { direct: 1.0, climbing: 0.9, diving: 1.3, weaving: 1.1 };
    const navState = enemyMissile.userData.navigationState || 'direct';
    enemyMissile.userData.speed = (enemyMissile.userData.baseSpeed || 1.0) * (speedModifiers[navState] || 1.0);
    
    // Close to target - switch to direct aggressive approach
    const distanceToTarget = enemyMissile.position.distanceTo(enemyMissile.userData.targetPosition);
    if (distanceToTarget < 50) { // Increased from 30 to be more aggressive earlier
        enemyMissile.userData.navigationState = 'direct';
        
        if (distanceToTarget < 30 && enemyMissile.position.y > enemyMissile.userData.targetPosition.y + 15) {
            // Close and above target - dive attack!
            enemyMissile.userData.navigationState = 'diving';
            
            // Calculate steeper diving angle
            const toTarget = new THREE.Vector3().subVectors(
                enemyMissile.userData.targetPosition,
                enemyMissile.position
            ).normalize();
            
            // More aggressive dive angle based on skill
            const diveIntensity = 0.3 + (enemyMissile.userData.pilotSkillLevel * 0.3);
            enemyMissile.userData.direction.lerp(toTarget, diveIntensity).normalize();
        } else {
            // Direct approach with higher responsiveness
            const toTarget = new THREE.Vector3().subVectors(
                enemyMissile.userData.targetPosition,
                enemyMissile.position
            ).normalize();
            
            // CHANGED: More responsive turning based on skill
            const turnRate = 0.2 + (enemyMissile.userData.pilotSkillLevel * 0.2); // 0.2-0.4
            enemyMissile.userData.direction.lerp(toTarget, turnRate).normalize();
        }
        return;
    }
    
    // Set up raycaster with longer distance for earlier obstacle detection
    raycaster.set(
        enemyMissile.position.clone(),
        enemyMissile.userData.direction.clone()
    );
    raycaster.far = obstacleCheckDistance * 1.5; // Look further ahead
    
    // Check for intersections with buildings
    const intersects = raycaster.intersectObjects(buildings);
    
    if (intersects.length > 0) {
        // Obstacle detected!
        const obstacleDistance = intersects[0].distance;
        const obstacleHeight = intersects[0].object.position.y + intersects[0].object.userData.height;
        const currentAltitude = enemyMissile.position.y;
        
        // IMPROVED: More intelligent obstacle avoidance strategy
        // Get missile skill and approach preference
        const isAggressive = enemyMissile.userData.isAggressive;
        const skillLevel = enemyMissile.userData.pilotSkillLevel;
        const preferHighAltitude = enemyMissile.userData.preferHighAltitude;
        
        // Check for easy over-the-top path
        const canClimbOver = currentAltitude + 30 > obstacleHeight || obstacleHeight < 80;
        
        // Check if we're high enough to simply dive
        const isHighEnough = currentAltitude > obstacleHeight + 40;
        
        // Aggressive missiles try to dive or weave more often
        if (isHighEnough && (isAggressive || Math.random() < 0.7)) {
            // We're high enough to dive over/through
            enemyMissile.userData.navigationState = 'diving';
            
            // Calculate more aggressive diving angle
            const toTarget = new THREE.Vector3().subVectors(
                enemyMissile.userData.targetPosition,
                enemyMissile.position
            ).normalize();
            
            // Aggressive missiles dive more directly
            const diveRate = isAggressive ? 0.3 : 0.2;
            enemyMissile.userData.direction.lerp(toTarget, diveRate).normalize();
        }
        // High-preference missiles or if obstacle is tall, climb
        else if (preferHighAltitude || !canClimbOver || Math.random() < 0.4) {
            // Choose climbing strategy
            enemyMissile.userData.navigationState = 'climbing';
            
            // More aggressive climb rate based on skill and obstacle height
            const heightNeeded = Math.max(20, obstacleHeight - currentAltitude + 30);
            const climbFactor = Math.min(0.8, heightNeeded / 100);
            
            // Update direction with more vertical component
            enemyMissile.userData.direction.y = Math.min(
                enemyMissile.userData.direction.y + climbFactor,
                0.9
            );
            enemyMissile.userData.direction.normalize();
        }
        else {
            // Choose weaving strategy with more intelligent vector calculation
            enemyMissile.userData.navigationState = 'weaving';
            
            // Get obstacle position and calculate better avoidance vector
            const obstaclePos = intersects[0].object.position.clone();
            
            // Calculate distance to obstacle center in xz plane
            const missilePos2D = new THREE.Vector2(enemyMissile.position.x, enemyMissile.position.z);
            const obstaclePos2D = new THREE.Vector2(obstaclePos.x, obstaclePos.z);
            const dist2D = missilePos2D.distanceTo(obstaclePos2D);
            
            // Determine if we should go left/right based on target position
            const targetPos2D = new THREE.Vector2(
                enemyMissile.userData.targetPosition.x,
                enemyMissile.userData.targetPosition.z
            );
            
            // Calculate vectors to determine optimal direction
            const vecToObstacle = new THREE.Vector2().subVectors(obstaclePos2D, missilePos2D).normalize();
            const vecToTarget = new THREE.Vector2().subVectors(targetPos2D, missilePos2D).normalize();
            
            // Cross product in 2D to determine which side of obstacle target is on
            const cross2D = vecToObstacle.x * vecToTarget.y - vecToObstacle.y * vecToTarget.x;
            
            // Choose direction based on cross product and add randomness for unpredictability
            enemyMissile.userData.weaveDirection = (cross2D > 0) ? 1 : -1;
            if (Math.random() < 0.2) enemyMissile.userData.weaveDirection *= -1; // 20% chance to do the opposite
            
            // Create perpendicular vector for weaving
            const missileToObstacle = obstaclePos.sub(enemyMissile.position).normalize();
            const weaveVector = new THREE.Vector3();
            weaveVector.crossVectors(missileToObstacle, new THREE.Vector3(0, 1, 0))
                .normalize()
                .multiplyScalar(enemyMissile.userData.weaveDirection);
                
            // Add slight upward component to avoid terrain
            weaveVector.y = 0.3; // More upward component (was 0.2)
            weaveVector.normalize();
            
            // Store avoidance vector
            enemyMissile.userData.obstacleAvoidanceVector = weaveVector;
            
            // More aggressive pilots weave more sharply
            const weaveSharpness = 0.15 + (skillLevel * 0.15); // 0.15-0.3
            enemyMissile.userData.direction.lerp(weaveVector, weaveSharpness).normalize();
        }
    }
    else {
        // No obstacles ahead - optimize path
        
        // If we're weaving, occasionally switch weave direction or return to direct
        if (enemyMissile.userData.navigationState === 'weaving') {
            if (Math.random() < 0.15) { // Increased from 0.1
                enemyMissile.userData.weaveDirection *= -1;
            }
            
            if (Math.random() < 0.2) { // 20% chance to return to direct after successful weave
                enemyMissile.userData.navigationState = 'direct';
            }
        }
        
        // If we're climbing and reached target altitude, return to direct
        if (enemyMissile.userData.navigationState === 'climbing' && 
            enemyMissile.position.y >= enemyMissile.userData.idealAltitude) {
            enemyMissile.userData.navigationState = 'direct';
        }
        
        // If we're diving and reached target altitude, return to direct
        if (enemyMissile.userData.navigationState === 'diving' && 
            enemyMissile.position.y <= enemyMissile.userData.targetPosition.y + 20) {
            enemyMissile.userData.navigationState = 'direct';
        }
        
        // Periodically adjust course toward target
        if (Math.random() < 0.2) { // Increased from 0.1
            // Calculate direction to target
            const toTarget = new THREE.Vector3().subVectors(
                enemyMissile.userData.targetPosition,
                enemyMissile.position
            ).normalize();
            
            // More aggressive course correction based on skill and state
            const correctionRate = enemyMissile.userData.isAggressive ? 
                0.2 + (enemyMissile.userData.pilotSkillLevel * 0.2) : // 0.2-0.4 for aggressive
                0.1 + (enemyMissile.userData.pilotSkillLevel * 0.1);  // 0.1-0.2 for cautious
                
            // Gradually adjust direction toward target
            enemyMissile.userData.direction.lerp(toTarget, correctionRate).normalize();
        }
    }
}

// Set up spatial audio for a player
function setupSpatialAudio(user, position) {
    if (!user.audioTrack) return;
    
    // Get player's 3D position relative to local player
    const relativePosition = position.clone().sub(missile.position);
    
    // Calculate distance (with max limit)
    const distance = Math.min(relativePosition.length(), 100);
    
    // Calculate panning (left-right) based on relative X position
    const pan = Math.max(-1, Math.min(1, relativePosition.x / 50)); 
    
    // Calculate volume based on distance
    const volume = Math.max(0, 1 - (distance / 100));
    
    // Apply spatial effects if supported
    if (user.audioTrack.setAudioProfiling) {
        user.audioTrack.setAudioProfiling({
            spatialRendering: true,
            spatialPosition: [pan, 0, -distance / 100]
        });
    }
    
    // Set volume based on distance
    user.audioTrack.setVolume(Math.floor(volume * 100));
}

// Update spatial audio in the animation loop
function updateSpatialAudio() {
    if (!rtcClient || !joinedChannel) return;
    
    // Update spatial audio for all remote users
    rtcClient.remoteUsers.forEach(user => {
        const otherPlayer = otherPlayers[user.uid];
        if (otherPlayer && otherPlayer.missile) {
            setupSpatialAudio(user, otherPlayer.missile.position);
        }
    });
}




function updatePortalMaterials(delta = 0.016) {
    if (!window.portalRings) return;
    
    for (const portal of window.portalRings) {
        if (portal.material && portal.material.uniforms && portal.material.uniforms.time) {
            portal.material.uniforms.time.value += delta;
        }
    }
}

// Add adaptive resolution during intense action
function adjustResolutionForPerformance() {
    if (explosionParticles.length > 80) {
        renderer.setPixelRatio(window.devicePixelRatio * 0.7);
    } else {
        renderer.setPixelRatio(window.devicePixelRatio);
    }
}

function initializeSettingsPanel() {
    // First, remove any existing settings panel or buttons
    const existingPanel = document.getElementById('settingsPanel');
    if (existingPanel) existingPanel.remove();
    
    const existingSettingsBtn = document.getElementById('settingsBtn');
    if (existingSettingsBtn) existingSettingsBtn.remove();
    
    // Create settings button
    const settingsBtn = document.createElement('button');
    settingsBtn.id = 'settingsBtn';
    settingsBtn.innerHTML = '⚙️';
    settingsBtn.style.position = 'absolute';
    settingsBtn.style.bottom = '60px';
    settingsBtn.style.right = '20px';
    settingsBtn.style.padding = '10px';
    settingsBtn.style.background = 'rgba(0,0,0,0.7)';
    settingsBtn.style.color = 'white';
    settingsBtn.style.border = '1px solid #444';
    settingsBtn.style.borderRadius = '5px';
    settingsBtn.style.cursor = 'pointer';
    settingsBtn.style.zIndex = '1002';
    settingsBtn.style.fontSize = '40px';
    settingsBtn.style.width = '80px';
    settingsBtn.style.height = '80px';
    settingsBtn.style.display = 'flex';
    settingsBtn.style.justifyContent = 'center';
    settingsBtn.style.alignItems = 'center';
    document.body.appendChild(settingsBtn);
    
    // Create settings panel
    const settingsPanel = document.createElement('div');
    settingsPanel.id = 'settingsPanel';
    settingsPanel.style.position = 'absolute';
    settingsPanel.style.bottom = '-500px'; // Ensure completely hidden
    settingsPanel.style.right = '20px';
    settingsPanel.style.width = '300px';
    settingsPanel.style.maxWidth = 'calc(100vw - 40px)'; // Responsive width
    settingsPanel.style.padding = '20px';
    settingsPanel.style.background = 'rgba(0,0,0,0.85)';
    settingsPanel.style.color = 'white';
    settingsPanel.style.border = '1px solid #ff3333';
    settingsPanel.style.borderRadius = '5px';
    settingsPanel.style.zIndex = '1001';
    settingsPanel.style.transition = 'bottom 0.3s ease-in-out';
    settingsPanel.style.fontFamily = 'Quantico, sans-serif';
    settingsPanel.style.boxShadow = '0 0 20px rgba(255, 0, 0, 0.3)';
    settingsPanel.style.boxSizing = 'border-box'; // Important for proper sizing
    
    // Add panel content
    settingsPanel.innerHTML = `
         <div style="margin-bottom: 20px; box-sizing: border-box; width: 100%;">
            <label for="playerNameInput" style="display: block; margin-bottom: 8px; font-size: 16px;">PILOT NAME:</label>
            <input type="text" id="playerNameInput" maxlength="15" 
                style="width: 100%; padding: 12px; background: #222; color: white; 
                border: 1px solid #444; border-radius: 4px; font-size: 16px; box-sizing: border-box;">
        </div>
        
        <div style="margin-bottom: 20px; box-sizing: border-box; width: 100%;">
            <label style="display: block; margin-bottom: 8px; font-size: 16px;">MISSILE COLOR:</label>
            <div id="settingsColorButtons" style="display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(5, 1fr); gap: 6px;">
                <!-- Color buttons will be generated here -->
            </div>
        </div>
        
        <div style="margin-bottom: 15px; box-sizing: border-box; width: 100%;">
            <label style="display: block; margin-bottom: 8px; font-size: 16px;">VOICE CHAT:</label>
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <span style="font-size: 14px;">Microphone</span>
                <button id="settingsMicToggle" style="padding: 8px 12px; background: #333; color: white; 
                    border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">OFF</button>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                <span style="font-size: 14px;">Voice Volume</span>
                <input type="range" id="voiceVolumeSlider" min="0" max="100" value="100" 
                    style="width: 60%; background: #333; height: 6px; outline: none; -webkit-appearance: none; border-radius: 3px;">
            </div>
        </div>
    `;
    document.body.appendChild(settingsPanel);

// Setup voice chat settings
    setTimeout(() => {
        // Voice chat toggle button
        const micToggle = document.getElementById('settingsMicToggle');
        if (micToggle) {
            micToggle.textContent = isAudioEnabled ? 'ON' : 'OFF';
            micToggle.style.background = isAudioEnabled ? '#ff3333' : '#333';
            
            micToggle.addEventListener('click', () => {
                toggleMicrophone();
                micToggle.textContent = isAudioEnabled ? 'ON' : 'OFF';
                micToggle.style.background = isAudioEnabled ? '#ff3333' : '#333';
            });
        }
        
        // Voice volume slider
        const volumeSlider = document.getElementById('voiceVolumeSlider');
        if (volumeSlider) {
            volumeSlider.addEventListener('input', (e) => {
                const volume = parseInt(e.target.value);
                // Set master remote user volume
                setVoiceChatVolume(volume);
            });
        }
    }, 100);

    document.body.appendChild(settingsPanel);
    
    // Add responsive style
    const responsiveStyle = document.createElement('style');
    responsiveStyle.textContent = `
        @media (max-width: 600px) {
            #settingsPanel {
                right: 10px;
                padding: 15px;
                width: calc(100vw - 20px);
            }
            
            #settingsBtn {
                right: 10px;
                width: 46px;
                height: 46px;
            }
            
            #settingsColorButtons {
                gap: 4px;
            }
            
            .settings-color-button {
                width: 20px !important;
                height: 20px !important;
            }
        }
    `;
    document.head.appendChild(responsiveStyle);
    
    // Set up event listeners for panel toggle
    settingsBtn.addEventListener('click', () => {
        if (settingsPanel.style.bottom.startsWith('-')) {
            settingsPanel.style.bottom = '140px';
        } else {
            settingsPanel.style.bottom = '-500px';
        }
    });
    
    // Add close when clicking outside the panel
    document.addEventListener('mousedown', function(event) {
        if (settingsPanel.style.bottom !== '-500px') {
            if (!settingsPanel.contains(event.target) && event.target !== settingsBtn) {
                settingsPanel.style.bottom = '-500px';
            }
        }
    });
    
    // IMPORTANT: Use setTimeout to ensure the DOM is ready before accessing elements
    setTimeout(() => {
        // Set up color buttons
        setupSettingsColorButtons();
        
        // Initialize inputs ONLY after DOM is ready
        const playerNameInput = document.getElementById('playerNameInput');
        if (playerNameInput) {
            playerNameInput.value = playerStats.name || '';
            
            // Setup name input event listener
            playerNameInput.addEventListener('input', function() {
                const newName = this.value.trim();
                if (newName) {
                    playerStats.name = newName;
                    updatePlayerInFirebase();
                    updateLeaderboard();
                }
            });
        }
        
        
    }, 100); // Increased timeout to ensure DOM is ready
}

// Setup color buttons in settings panel
function setupSettingsColorButtons() {
    const colors = [
        // Row 1: Red spectrum
        "#ff0000", "#ff3333", "#ff6666", "#ff9999", "#8e2522", "#ff5500", "#cc3300", "#aa2200",
        // Row 2: Orange/Yellow spectrum
        "#ff8800", "#ffaa00", "#ffcc00", "#ffdd55", "#ffff00", "#ffff66", "#eeee33", "#dddd00",
        // Row 3: Green spectrum
        "#00cc00", "#00ff00", "#33ff33", "#66ff66", "#99ff99", "#00aa44", "#008833", "#006622",
        // Row 4: Blue spectrum
        "#0000ff", "#3333ff", "#6666ff", "#0099ff", "#33ccff", "#66ffff", "#0099cc", "#006699",
        // Row 5: Purple/Pink/Special spectrum
        "#6600cc", "#9900ff", "#cc00ff", "#ff00ff", "#ff66ff", "#ff3399", "#ffffff", "#000000"
    ];
    
    const colorButtonsContainer = document.getElementById('settingsColorButtons');
    if (!colorButtonsContainer) return;
    
    // Clear any existing buttons
    colorButtonsContainer.innerHTML = '';
    
    // Create color buttons
    colors.forEach((color) => {
        const button = document.createElement('div');
        button.className = 'settings-color-button';
        button.style.width = '24px';
        button.style.height = '24px';
        button.style.backgroundColor = color;
        button.style.borderRadius = '4px';
        button.style.cursor = 'pointer';
        button.style.border = '2px solid #333';
        button.style.transition = 'transform 0.2s, border-color 0.2s';
        button.style.boxSizing = 'border-box';
        
        // Select button if it's the current color
        if (color === playerStats.color) {
            button.style.border = '2px solid #ffffff';
            button.style.boxShadow = '0 0 5px rgba(255, 255, 255, 0.8)';
        }
        
        // Handle selection with immediate application
        button.addEventListener('click', function() {
            // Remove selection from all buttons
            document.querySelectorAll('.settings-color-button').forEach(btn => {
                btn.style.border = '2px solid #333';
                btn.style.boxShadow = 'none';
            });
            
            // Add selection to clicked button
            this.style.border = '2px solid #ffffff';
            this.style.boxShadow = '0 0 5px rgba(255, 255, 255, 0.8)';
            
            // Update player color immediately
            playerStats.color = color;
            
            // Apply color to missile
            if (missile && missile.children && missile.children[0]) {
                missile.children[0].material.color.set(color);
            }
            updatePlayerMarkerColor();
            
            // Save to Firebase
            updatePlayerInFirebase();
            
            // Update leaderboard
            updateLeaderboard();
        });
        
        colorButtonsContainer.appendChild(button);
    });
}

function createSoundButton() {
    // Remove any existing sound buttons outside settings panel
    const allSoundButtons = document.querySelectorAll('button[id="soundBtn"], button[data-sound-button="true"]');
    allSoundButtons.forEach(btn => btn.remove());
    
    // Also look for any buttons that might be sound buttons by innerHTML content
    document.querySelectorAll('button').forEach(btn => {
        if (btn.innerHTML === '🔊' || btn.innerHTML === '🔇') {
            btn.remove();
        }
    });
    
    // Create a new sound button with matching style to the settings button
    const soundBtn = document.createElement('button');
    soundBtn.id = 'soundBtn';
    soundBtn.innerHTML = sounds.muted ? '🔇' : '🔊';
    soundBtn.setAttribute('data-sound-button', 'true');
    
    // Position at bottom right, next to settings button
    soundBtn.style.position = 'absolute';
    soundBtn.style.bottom = '60px'; // Same height as settings button
    soundBtn.style.right = '130px'; // 20px (settings right margin) + 50px (settings width) + 10px (gap)
    soundBtn.style.padding = '10px';
    soundBtn.style.background = 'rgba(0,0,0,0.7)';
    soundBtn.style.color = 'white';
    soundBtn.style.border = '1px solid #444';
    soundBtn.style.borderRadius = '5px';
    soundBtn.style.cursor = 'pointer';
    soundBtn.style.zIndex = '1002'; // Same z-index as settings button
    soundBtn.style.fontSize = '40px';
    soundBtn.style.width = '80px';
    soundBtn.style.height = '80px';
    soundBtn.style.display = 'flex';
    soundBtn.style.justifyContent = 'center';
    soundBtn.style.alignItems = 'center';
    
    // Toggle mute on click
    soundBtn.addEventListener('click', () => {
        toggleMute();
        soundBtn.innerHTML = sounds.muted ? '🔇' : '🔊';
        
        // Also update the mute button in settings panel if it exists
        const settingsMuteBtn = document.getElementById('settingsMuteBtn');
        if (settingsMuteBtn) {
            settingsMuteBtn.innerHTML = sounds.muted ? '🔇' : '🔊';
        }
    });
    
    document.body.appendChild(soundBtn);
    
    // Add responsive style
    const responsiveStyle = document.createElement('style');
    responsiveStyle.textContent = `
        @media (max-width: 600px) {
            #soundBtn {
                right: 70px;
                width: 46px;
                height: 46px;
                font-size: 20px;
            }
        }
    `;
    document.head.appendChild(responsiveStyle);
    
    return soundBtn;
}

// Toggle microphone on/off
function toggleMicrophone() {
    if (!localAudioTrack) {
        console.error("No audio track available. Voice chat may not be initialized.");
        
        // Create a dummy audio track to at least allow toggling the UI state
        localAudioTrack = {
            setEnabled: function(enabled) {
                console.log("Dummy mic set to:", enabled);
                isAudioEnabled = enabled;
                updateVoiceChatUI();
            }
        };
    }
    
    isAudioEnabled = !isAudioEnabled;
    localAudioTrack.setEnabled(isAudioEnabled);
    
    console.log("Microphone toggled:", isAudioEnabled ? "on" : "off");
    updateVoiceChatUI();
    
    // Also update the settings panel button
    const settingsMicToggle = document.getElementById('settingsMicToggle');
    if (settingsMicToggle) {
        settingsMicToggle.textContent = isAudioEnabled ? 'ON' : 'OFF';
        settingsMicToggle.style.background = isAudioEnabled ? '#ff3333' : '#333';
    }
}

// Leave voice chat
async function leaveAgoraChannel() {
    if (!rtcClient || !joinedChannel) return;
    
    // Stop and close local tracks
    if (localAudioTrack) {
        localAudioTrack.stop();
        localAudioTrack.close();
        localAudioTrack = null;
    }
    
    // Leave the channel
    await rtcClient.leave();
    console.log("Left Agora channel");
    
    joinedChannel = false;
    updateVoiceChatUI();
}

// Create voice chat UI
function createVoiceChatUI() {
    // Create voice chat container
    const voiceChatContainer = document.createElement('div');
    voiceChatContainer.id = 'voice-chat-container';
    voiceChatContainer.style.position = 'absolute';
    voiceChatContainer.style.bottom = '60px';
    voiceChatContainer.style.right = '240px'; // Position next to the settings button
    voiceChatContainer.style.zIndex = '1002';
    
    // Create mic button
    const micButton = document.createElement('button');
    micButton.id = 'micButton';
    micButton.innerHTML = '🎤';
    micButton.style.width = '80px';
    micButton.style.height = '80px';
    micButton.style.borderRadius = '5px';
    micButton.style.background = 'rgba(0,0,0,0.7)';
    micButton.style.color = 'white';
    micButton.style.border = '1px solid #444';
    micButton.style.fontSize = '40px';
    micButton.style.cursor = 'pointer';
    micButton.style.display = 'flex';
    micButton.style.justifyContent = 'center';
    micButton.style.alignItems = 'center';
    micButton.style.transition = 'all 0.2s ease-in-out'; 
    
    // Add mic button functionality
    micButton.addEventListener('click', toggleMicrophone);
    
    // Add mic button to container
    voiceChatContainer.appendChild(micButton);
    
    // Add container to document
    document.body.appendChild(voiceChatContainer);
    
    // Add voice chat participants list (hidden initially)
    const participantsList = document.createElement('div');
    participantsList.id = 'voice-participants';
    participantsList.style.position = 'absolute';
    participantsList.style.bottom = '140px';
    participantsList.style.right = '140px';
    participantsList.style.background = 'rgba(0,0,0,0.7)';
    participantsList.style.color = 'white';
    participantsList.style.padding = '10px';
    participantsList.style.borderRadius = '5px';
    participantsList.style.border = '1px solid #ff3333';
    participantsList.style.fontSize = '14px';
    participantsList.style.zIndex = '1001';
    participantsList.style.display = 'none'; // Initially hidden
    
    document.body.appendChild(participantsList);
    
    // Add responsive CSS for mobile
    const responsiveStyle = document.createElement('style');
    responsiveStyle.textContent = `
        @media (max-width: 600px) {
            #voice-chat-container {
                right: 130px;
            }
            
            #micButton {
                width: 46px;
                height: 46px;
                font-size: 20px;
            }
            
            #voice-participants {
                right: 130px;
                bottom: 130px;
                max-width: calc(100vw - 140px);
            }
        }
    `;
    document.head.appendChild(responsiveStyle);

    // Update UI initially
    updateVoiceChatUI();
}

// Update voice chat UI based on state
function updateVoiceChatUI() {
    const micButton = document.getElementById('micButton');
    if (!micButton) return;
    
    // Enhanced visual feedback when mic is active/inactive
    if (isAudioEnabled) {
        // Active microphone
        micButton.innerHTML = '🎤';
        micButton.style.background = 'rgba(255,51,51,0.7)'; // Red background when active
        micButton.style.boxShadow = '0 0 10px rgba(255,51,51,0.7)'; // Glow effect
        micButton.style.border = '1px solid #ff3333';
        micButton.setAttribute('title', 'Microphone ON - Click to mute');
    } else {
        // Muted microphone
        micButton.innerHTML = '🎤';
        micButton.style.background = 'rgba(0,0,0,0.7)'; // Dark when muted
        micButton.style.boxShadow = 'none';
        micButton.style.border = '1px solid #444';
        micButton.setAttribute('title', 'Microphone OFF - Click to unmute');
    }
}

// Visualize who is speaking
function showSpeakingIndicator(uid, volumeLevel = 50) {
    // Find the player associated with this uid
    let playerName = "Unknown";
    let playerColor = "#ffffff";
    
    if (uid === playerStats.id) {
        playerName = playerStats.name;
        playerColor = playerStats.color || "#ffffff";
    } else if (otherPlayers[uid]) {
        playerName = otherPlayers[uid].name;
        playerColor = otherPlayers[uid].color || "#ffffff";
    }
    
    // Ensure the color is readable with a text shadow
    let displayColor = playerColor;
    
    // Get participants list
    let participantsList = document.getElementById('voice-participants');
    if (!participantsList) return;
    
    // Show participants list
    participantsList.style.display = 'block';
    
    // Create a ping animation style if not exists
    if (!document.getElementById('voice-ping-animation')) {
        const style = document.createElement('style');
        style.id = 'voice-ping-animation';
        style.textContent = `
            @keyframes voicePing {
                0% { transform: scale(0.95); opacity: 0.7; }
                50% { transform: scale(1.05); opacity: 1; }
                100% { transform: scale(0.95); opacity: 0.7; }
            }
            .speaking {
                animation: voicePing 0.5s infinite;
                text-shadow: 0 0 5px #fff, 0 0 10px rgba(255,255,255,0.5);
            }
        `;
        document.head.appendChild(style);
    }
    
    // Add or update participant
    let participant = document.getElementById(`voice-participant-${uid}`);
    if (!participant) {
        participant = document.createElement('div');
        participant.id = `voice-participant-${uid}`;
        participant.className = 'speaking';
        participant.style.color = displayColor;
        participant.style.textShadow = '0 0 5px #000, 0 0 3px rgba(255,255,255,0.5)';
        participant.style.margin = '5px 0';
        participant.style.padding = '5px';
        participant.style.borderRadius = '3px';
        participant.style.transition = 'all 0.2s ease';
        participantsList.appendChild(participant);
        
        // Add sound effect for new speaker
        if (sounds && !sounds.muted) {
            playSound('ui');
        }
    }
    
    // Get volume level icon based on volume
    let volumeIcon = '🔈';
    if (volumeLevel > 70) volumeIcon = '🔊';
    else if (volumeLevel > 30) volumeIcon = '🔉';
    
    // Update participant display
    participant.innerHTML = `${volumeIcon} ${playerName} speaking...`;
    participant.className = 'speaking'; // Add animation class
    
    // Set timeout to remove the indicator if not updated for 2 seconds
    if (participant.hideTimeout) clearTimeout(participant.hideTimeout);
    participant.hideTimeout = setTimeout(() => hideSpeakingIndicator(uid), 2000);
}

function hideSpeakingIndicator(uid) {
    let participant = document.getElementById(`voice-participant-${uid}`);
    if (participant) {
        participant.remove();
    }
    
    // Hide participants list if empty
    let participantsList = document.getElementById('voice-participants');
    if (participantsList && participantsList.children.length === 0) {
        participantsList.style.display = 'none';
    }
}

function updateSpeakingIndicatorVolume(uid, level) {
    let participant = document.getElementById(`voice-participant-${uid}`);
    if (!participant) return;
    
    const indicator = participant.querySelector('.voice-indicator');
    if (!indicator) return;
    
    // Update indicator based on volume level
    if (level > 50) {
        indicator.innerHTML = "🔴"; // High volume
        indicator.style.color = "#ff3333";
    } else if (level > 20) {
        indicator.innerHTML = "🟡"; // Medium volume
        indicator.style.color = "#ffcc00";
    } else {
        indicator.innerHTML = "⚪"; // Low/no volume
        indicator.style.color = "#aaaaaa";
    }
}

// Set voice chat volume
function setVoiceChatVolume(volumePercent) {
    if (!rtcClient) return;
    
    // AgoraRTC volume is 0-100
    const volume = Math.max(0, Math.min(100, volumePercent));
    
    // Set playback volume for all remote users
    rtcClient.remoteUsers.forEach(user => {
        if (user.audioTrack) {
            user.audioTrack.setVolume(volume);
        }
    });
    
    console.log(`Voice chat volume set to ${volume}%`);
}


function enhanceMobileControls() {
    if (!isMobile) return;
    
    // Make sure our touch handlers prevent default browser behavior
    function betterTouchStart(e) {
        e.preventDefault();
        isAccelerating = true;
        updateFlightSound(true);
    }
    
    function betterTouchEnd(e) {
        e.preventDefault();
        isAccelerating = false;
        updateFlightSound(false);
    }
    
    // Remove existing listeners and add our improved ones
    renderer.domElement.removeEventListener('touchstart', handleTouchStart);
    renderer.domElement.removeEventListener('touchend', handleTouchEnd);
    
    renderer.domElement.addEventListener('touchstart', betterTouchStart, { passive: false });
    renderer.domElement.addEventListener('touchend', betterTouchEnd, { passive: false });
    
    console.log("Enhanced mobile controls applied");
}


// Function to update stats for a specific pilot
function updateSpecificPilotStats(pilotId, isHit, isDestroyed) {
    // Find the pilot in the stats array
    const pilotIndex = enemyPilotStats.findIndex(pilot => pilot.id === pilotId);
    
    // If pilot not found, exit
    if (pilotIndex === -1) return;
    
    const pilot = enemyPilotStats[pilotIndex];
    
    // Update stats
    if (isHit && isDestroyed) {
        pilot.targetsDestroyed++;
    } else {
        pilot.crashes++;
    }
    
    // Update TPM properly based on total time
    pilot.tpm = calculateTPM(pilot.targetsDestroyed, pilot.totalPlayTimeSeconds);
    
    // Update leaderboard immediately
    updateLeaderboard();
}

// Initialize enemy pilot stats with more realistic and identifiable data
function initializeEnemyPilots() {
    // NATO phonetic alphabet names
    const natoNames = [
        "Alpha", "Bravo", "Charlie", "Delta", "Echo", 
        "Foxtrot", "Golf", "Hotel", "India", "Juliet", 
        "Kilo", "Lima", "Mike", "November", "Oscar", 
        "Papa", "Quebec", "Romeo", "Sierra", "Tango", 
        "Uniform", "Victor", "Whiskey", "X-ray", "Yankee", "Zulu"
    ];
    
    // Create array to track used names to avoid duplicates
    const usedNames = [];
    
    // Predefined colors for enemy pilots to ensure good visibility
    const enemyColors = ["#ff5500", "#66ccff", "#66ff66", "#ffcc00", "#ff00ff"];
    
    enemyPilotStats = [];
    
    // Create 5 enemy pilots
    for (let i = 0; i < 5; i++) {
        // Find an unused NATO name
        let nameIndex;
        do {
            nameIndex = Math.floor(Math.random() * natoNames.length);
        } while (usedNames.includes(nameIndex) && usedNames.length < natoNames.length);
        
        // If all names are used, we'll allow duplicates
        usedNames.push(nameIndex);
        
        // Generate random number for the callsign
        const randomNumber = Math.floor(Math.random() * 99) + 1;
        const pilotName = `${natoNames[nameIndex]}-${randomNumber}`;
        
        // Add to enemy pilots array
        enemyPilotStats.push({
            id: `cpu_${i+1}`,
            name: pilotName,
            targetsDestroyed: 0, 
            crashes: 0, 
            roundsWon: 0, 
            color: enemyColors[i % enemyColors.length]
        });
    }
}

function syncEnemyPilotsWithFirebase() {
    if (!db) return;
    
    // First check if enemy pilots already exist in Firebase
    db.collection("gameSessions").doc("current").get()
        .then(doc => {
            if (doc.exists && doc.data().enemyPilots) {
                console.log("Loading shared enemy pilots from Firebase");
                // Use the shared enemy pilots
                enemyPilotStats = doc.data().enemyPilots;
                updateLeaderboard();
            } else {
                console.log("Creating and sharing enemy pilots to Firebase");
                // Initialize enemy pilots locally first
                initializeEnemyPilots();
                
                // Then save to Firebase for other players
                db.collection("gameSessions").doc("current").set({
                    enemyPilots: enemyPilotStats,
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                }, { merge: true });
            }
        })
        .catch(error => {
            console.error("Error syncing enemy pilots:", error);
            // Fall back to local generation if Firebase fails
            initializeEnemyPilots();
        });
}



function determineRoundWinner() {
    // Create a copy of all pilots including the player
    const allPilots = [...enemyPilotStats, playerStats];
    
    // Filter out pilots with no kills
    const pilotsWithKills = allPilots.filter(pilot => pilot.targetsDestroyed > 0);
    
    if (pilotsWithKills.length === 0) {
        return null; // No winner (nobody got any kills)
    }
    
    // Sort by targets destroyed (highest first)
    pilotsWithKills.sort((a, b) => b.targetsDestroyed - a.targetsDestroyed);
    
    // Get pilots with the highest kill count
    const highestKills = pilotsWithKills[0].targetsDestroyed;
    const tiedPilots = pilotsWithKills.filter(pilot => pilot.targetsDestroyed === highestKills);
    
    // If there's only one winner, return them
    if (tiedPilots.length === 1) {
        const winner = tiedPilots[0];
        winner.roundsWon += 1;
        return [winner];
    }
    
     // Calculate round duration in seconds
     const roundDurationInSeconds = Math.max(10, elapsedTime / 1000);
    
    // If there are multiple pilots tied for first place, use TPM as a tiebreaker
    tiedPilots.sort((a, b) => {
        // Calculate TPM using the same round duration for both pilots
        const aTpm = a.targetsDestroyed / (roundDurationInSeconds / 60);
        const bTpm = b.targetsDestroyed / (roundDurationInSeconds / 60);
        return bTpm - aTpm; // Higher TPM (faster pilot) comes first
    });
    
    // The winner is the fastest pilot (highest TPM)
    const winner = tiedPilots[0];
    winner.roundsWon += 1;
    
    // Return just the single fastest pilot as the winner
    return [winner];
}

function initFlightSoundPool() {
    // Create small pools for each flight sound
    window.flightSoundPool = {
        flight1: [sounds.flight1],
        flight2: [sounds.flight2]
    };
    
    // Add 1 additional sound to each pool
    for (let i = 0; i < 1; i++) {
        const normalSound = new Audio('flight1.mp3');
        normalSound.loop = true;
        normalSound.volume = 0.4;
        
        const accelSound = new Audio('flight2.mp3');
        accelSound.loop = true;
        accelSound.volume = 0.5;
        
        window.flightSoundPool.flight1.push(normalSound);
        window.flightSoundPool.flight2.push(accelSound);
    }
    
    // Track which sound is currently playing
    window.currentFlightIndex = 0;
}








function playEnemyExplosionSound() {
    if (sounds.muted) return;
    
    if (!window.explosionSoundPool) {
        initSoundPool();
    }
    
    // Get next sound in pool
    const sound = window.explosionSoundPool[window.explosionSoundIndex];
    window.explosionSoundIndex = (window.explosionSoundIndex + 1) % window.explosionSoundPool.length;
    
    // Reset and play
    sound.pause();
    sound.currentTime = 0;
    sound.play().catch(e => {});
}

// Handle enemy missile hitting a target building
function handleEnemyTargetHit(target) {
    // Ensure this is actually a target building
    if (!target || !target.userData || !target.userData.isTarget) {
        return; // Do not process non-target buildings
    }
    const targetPosition = target.position.clone();
    const buildingWidth = target.userData.width;  // Get width for scorch size
    
   // Use the same explosion function as player missiles
   createExplosion(targetPosition, false, false);
    
    // Screen shake
    screenShakeTime = 0.6;
    screenShakeIntensity = 1.2;

      // Find the missile that hit this target
      const hitMissileIndex = enemyMissiles.findIndex(missile => 
        missile.userData.targetBuilding === target);
    
    // Get pilot ID from missile if available
    let pilotId = null;
    if (hitMissileIndex >= 0) {
        pilotId = enemyMissiles[hitMissileIndex].userData.pilotId;
        console.log(`Target hit by missile with pilot ID: ${pilotId}`);
        
        // Update pilot stats for the enemy that hit the target
        if (pilotId) {
            // Find the pilot
            const pilotIndex = enemyPilotStats.findIndex(pilot => pilot.id === pilotId);
            if (pilotIndex !== -1) {
                // Update stats
                enemyPilotStats[pilotIndex].targetsDestroyed++;
                
                // IMPORTANT: Update the leaderboard entry directly as well
                const leaderboardIndex = leaderboard.findIndex(entry => entry.id === pilotId);
                if (leaderboardIndex !== -1) {
                    leaderboard[leaderboardIndex].targetsDestroyed = enemyPilotStats[pilotIndex].targetsDestroyed;
                    leaderboard[leaderboardIndex].tpm = calculateTPM(
                        enemyPilotStats[pilotIndex].targetsDestroyed, 
                        enemyPilotStats[pilotIndex].totalPlayTimeSeconds || 1
                    );
                }
                
                // Update the leaderboard UI immediately
                updateLeaderboard();
                console.log(`Updated stats for pilot ${enemyPilotStats[pilotIndex].name}: ${enemyPilotStats[pilotIndex].targetsDestroyed} kills`);
            }
        }
    }
    
        
    // Remove target from scene and arrays
    scene.remove(target);
    const targetIndex = buildings.indexOf(target);
    if (targetIndex > -1) {
        buildings.splice(targetIndex, 1);
    }
    
    const targetBuildingIndex = targetBuildings.indexOf(target);
    if (targetBuildingIndex > -1) {
        targetBuildings.splice(targetBuildingIndex, 1);

        // Create a ground scorch mark where the building was
        const scorchPosition = new THREE.Vector3(targetPosition.x, -0.3, targetPosition.z);
        createScorchMark(scorchPosition, false);

         // Make it slightly larger than normal - THIS WAS MISSING
         const lastScorch = scorchMarks[scorchMarks.length - 1];
        if (lastScorch) {
            const scorchSize = buildingWidth * 1.2; // Slightly bigger than building base
            lastScorch.scale.set(scorchSize, scorchSize, 1);
            
            if (lastScorch.userData.emberEffect) {
                lastScorch.userData.emberEffect.scale.set(scorchSize * 0.8, scorchSize * 0.8, 1);
            }
            
            // Make this scorch produce more smoke
            lastScorch.userData.smokeIntensity = 1.5;
            lastScorch.userData.isTargetHit = true;
        }
        
        // Create smoke column 
        createSmokeColumn(scorchPosition, 20);
        
        // Update stats
        stats.targetsRemaining--;
        document.getElementById('targetsRemaining').textContent = stats.targetsRemaining;

         // Update the UI if needed
    const targetsElement = document.getElementById('targetsRemaining');
    if (targetsElement) {
        targetsElement.textContent = stats.targetsRemaining;
    }
    
        
        // Check if all targets are destroyed
        if (stats.targetsRemaining <= 0) {
        // IMPORTANT: Set roundAlreadyWon to prevent player from getting credit
        window.roundAlreadyWon = true;
        
        // Mark this enemy pilot as the winner of the round
        if (pilotId) {
            const winningPilot = enemyPilotStats.find(pilot => pilot.id === pilotId);
            if (winningPilot) {
                winningPilot.roundsWon++;
                console.log(`Enemy pilot ${winningPilot.name} won the round!`);
                // Update leaderboard
                updateLeaderboard();
            }
        }
        
        window.gameOverTriggered = true;
        gameActive = false;
        
        setTimeout(() => {
            showGameOver();
        }, 1000);
        }
    }
}

// Limit total number of scorch marks
function limitScorchMarks() {
    while (scorchMarks.length > 75) {
        const oldest = scorchMarks.shift();
        if (oldest.userData.flickerInterval) {
            clearInterval(oldest.userData.flickerInterval);
        }
        disposeObject(oldest);
    }
}

function updateDamagedBuildingsSmoke() {
    // Only proceed if we have damaged buildings
    if (damagedBuildings.length === 0) return;
    
    // Process each damaged building
    for (let i = damagedBuildings.length - 1; i >= 0; i--) {
        const building = damagedBuildings[i];
        
        // Skip if building no longer exists in main buildings array
        if (!buildings.includes(building)) {
            damagedBuildings.splice(i, 1);
            continue;
        }
        
        // Emit smoke with global timer efficiency
        if (Math.random() < 0.4) { // 40% chance per building per global interval
            // Call the correct smoke creation function
            const smokeSource = new THREE.Vector3(
                building.position.x + THREE.MathUtils.randFloatSpread(building.userData.width * 0.5),
                building.position.y + building.userData.height * 0.5,
                building.position.z + THREE.MathUtils.randFloatSpread(building.userData.width * 0.5)
            );
            createDamagedBuildingSmoke(smokeSource, building.userData.damageLevel);
        }
    }
}



// Create smoke for enemy missiles
function createEnemyMissileSmoke(enemyMissile) {
    const smokeGeometry = new THREE.SphereGeometry(0.4, 8, 8);
    const smokeMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x555555,
        transparent: true,
        opacity: 0.5,
        depthWrite: false
    });
    
    const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
    
    // Position behind missile
    const missileBackVector = enemyMissile.userData.direction.clone().negate();
    smoke.position.copy(enemyMissile.position)
        .add(missileBackVector.multiplyScalar(4))
        .add(new THREE.Vector3(
            THREE.MathUtils.randFloatSpread(0.5),
            THREE.MathUtils.randFloatSpread(0.5),
            THREE.MathUtils.randFloatSpread(0.5)
        ));
    
    smoke.userData = {
        life: 0.8,
        maxLife: 0.8,
        growRate: 1.03,
        velocity: new THREE.Vector3(
            THREE.MathUtils.randFloatSpread(0.05),
            THREE.MathUtils.randFloat(0.02, 0.1),
            THREE.MathUtils.randFloatSpread(0.05)
        )
    };
    
    scene.add(smoke);
    smokeParticles.push(smoke);
}

function addDummyPlayers() {
    // Don't add fake data - we'll track real enemy missile stats
    initializeLeaderboard();
}


function createLeaderboard() {
    // Create leaderboard container if it doesn't exist
    if (!document.getElementById('leaderboard')) {
        const leaderboardDiv = document.createElement('div');
        leaderboardDiv.id = 'leaderboard';
        leaderboardDiv.innerHTML = `
            <div class="leaderboard-title">TOP PILOTS</div>
            <div id="leaderboard-entries">
                <!-- Will be populated dynamically -->
            </div>
        `;
        document.body.appendChild(leaderboardDiv);
        
        // Add CSS for the leaderboard with reduced width
        const style = document.createElement('style');
        style.textContent = `
            #leaderboard {
                position: absolute;
                top: 20px;
                right: 20px;
                background-color: rgba(0, 0, 0, 0.7);
                border: 1px solid #ff3333;
                border-radius: 5px;
                padding: 15px 40px;
                font-family: 'Quantico', sans-serif;
                color: white;
                width: 200px; /* Reduced from 280px */
                z-index: 100;
            }
            
            .leaderboard-title {
                font-size: 22px;
                font-weight: bold;
                text-align: center;
                margin-bottom: 10px;
                color: #66ccff;
            }
            
            .leaderboard-header {
                display: flex;
                justify-content: flex-start;
                font-size: 18px;
                padding: 4px 0;
                margin-bottom: 5px;
                color: #aaaaaa;
                border-bottom: 1px solid #444;
            }
            
            .leaderboard-row {
                display: flex;
                justify-content: flex-start;
                padding: 4px 0;
                margin-bottom: 2px;
                font-size: 18px;
                border-radius: 3px;
                border-left: 3px solid transparent;
            }
            
            .player-row {
                border-left: 3px solid #ff3333;
                background: rgba(255, 51, 51, 0.1);
                padding-left: 3px;
            }
            
            .name-col {
                flex-grow: 1;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                font-weight: bold;
                max-width: 125px; /* Adjusted for smaller leaderboard */
                padding-right: 5px;
            }
            
            .score-col {
                width: 40px;
                text-align: right;
                font-weight: bold;
            }
            
            .leaderboard-row.highlight {
                animation: highlight-pulse 1.5s ease-out;
            }
            
            @keyframes highlight-pulse {
                0% { background-color: rgba(255, 255, 255, 0.3); }
                100% { background-color: transparent; }
            }
        `;
        document.head.appendChild(style);
    }
    
    // Initial update
    updateLeaderboard();
}

// Update player stats to properly track time and calculate TPM
function updatePlayerStats(deltaTime) {
    // Only update while game is active
    if (!gameActive) return;
    
    // Update total play time (in seconds) - use passed deltaTime for more accuracy
    if (deltaTime) {
        playerStats.totalPlayTimeSeconds += deltaTime;
    } else {
        // Fallback to 1/60th of a second if no delta provided
        playerStats.totalPlayTimeSeconds += 1/60;
    }
    
    // Recalculate TPM with the correct arguments
    playerStats.tpm = calculateTPM(
        playerStats.targetsDestroyed, 
        playerStats.totalPlayTimeSeconds
    );
}

// Function to calculate Targets Per Minute (TPM) rate
function calculateTPM(kills, totalTimeSeconds) {
    if (!totalTimeSeconds || totalTimeSeconds <= 0) return 0;
    
    // More precise TPM calculation
    return (kills / totalTimeSeconds) * 60;
}

// Add function to update the leaderboard
function updateLeaderboard() {
    // Get leaderboard element
    const leaderboardElement = document.getElementById('leaderboard');
    if (!leaderboardElement) return;

    // Debug output to help identify the issue
    console.log("Updating leaderboard with player:", playerStats.name, 
                "ID:", playerStats.id, 
                "Kills:", playerStats.targetsDestroyed);
    
    // Create HTML content - start with header
    let html = `
        <div class="leaderboard-title">LEADERBOARD</div>
        <table class="leaderboard-table">
            <thead>
                <tr>
                    <th class="name-col">PILOT</th>
                    <th class="kills-col">KILLS</th>
                    <th class="rounds-col">ROUNDS</th>
                </tr>
            </thead>
            <tbody>
    `;
    
    // Create a fresh array for sorting
    let displayEntries = [];
    
    // ALWAYS add the current player first - guaranteed inclusion
    displayEntries.push({
        id: playerStats.id,
        name: playerStats.name,
        targetsDestroyed: playerStats.targetsDestroyed || 0,
        roundsWon: playerStats.roundsWon || 0,
        tpm: playerStats.tpm || 0,
        color: playerStats.color || "#ffffff",
        isPlayer: true
    });
    
    // Add all enemy pilots
    enemyPilotStats.forEach(pilot => {
        displayEntries.push({
            id: pilot.id,
            name: pilot.name,
            targetsDestroyed: pilot.targetsDestroyed || 0,
            roundsWon: pilot.roundsWon || 0,
            tpm: pilot.tpm || 0,
            color: pilot.color || "#66ccff",
            isEnemyPilot: true
        });
    });
    
    // Sort by targets destroyed (descending)
    displayEntries.sort((a, b) => (b.targetsDestroyed || 0) - (a.targetsDestroyed || 0));
    
    // Generate entries (limited to top 6 for performance)
    const displayLimit = 6; 
    displayEntries.slice(0, displayLimit).forEach(player => {
        // Check if this is the current player
        const isCurrentPlayer = player.id === playerStats.id || player.isPlayer;
        
        // Get player's color or use default
        const playerColor = player.color || "#ffffff";
        
        // Create row with color-styled name
        html += `
            <tr class="${isCurrentPlayer ? 'you' : ''}">
                <td class="name-col">
                    <span style="color: ${playerColor}; text-shadow: 0 0 3px #000, 0 0 2px rgba(255,255,255,0.5);">
                        ${player.name || "Unknown"}
                    </span>
                </td>
                <td class="kills-col">${player.targetsDestroyed || 0}</td>
                <td class="rounds-col">${player.roundsWon || 0}</td>
            </tr>
        `;
    });
    
    // Close the table
    html += `
            </tbody>
        </table>
    `;
    
    // Update the DOM
    leaderboardElement.innerHTML = html;
    
    // Add CSS styles for the table
    const leaderboardStyle = document.getElementById('leaderboard-style');
    if (!leaderboardStyle) {
        const style = document.createElement('style');
        style.id = 'leaderboard-style';
        style.textContent = `
            #leaderboard {
                width: 280px !important;
                padding: 15px !important;
            }
            
            .leaderboard-table {
                width: 100%;
                border-collapse: separate;
                border-spacing: 0 2px;
            }
            
            .leaderboard-table thead th {
                color: #aaaaaa;
                font-size: 16px;
                text-align: left;
                padding-bottom: 6px;
                border-bottom: 1px solid #444;
            }
            
            .leaderboard-table tbody tr {
                height: 28px;
            }
            
            .leaderboard-table tbody tr.you {
                background: rgba(255, 51, 51, 0.1);
                border-left: 2px solid #ff3333;
            }
            
            .leaderboard-table td {
                padding: 4px 6px;
            }
            
            .name-col {
                width: 140px;
                text-align: left;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }
            
            .kills-col {
                width: 60px;
                text-align: center;
                font-weight: bold;
            }
            
            .rounds-col {
                width: 60px;
                text-align: center;
                font-weight: bold;
            }
        `;
        document.head.appendChild(style);
    }
}

// Helper function to ensure colors are readable against dark background
function ensureReadableColor(color) {
    try {
        // Parse the color (handles both hex and rgb formats)
        let r, g, b;
        
        if (color.startsWith('#')) {
            // Handle hex format
            const hex = color.substring(1);
            r = parseInt(hex.substr(0, 2), 16);
            g = parseInt(hex.substr(2, 2), 16);
            b = parseInt(hex.substr(4, 2), 16);
        } else if (color.startsWith('rgb')) {
            // Handle rgb format
            const matches = color.match(/(\d+),\s*(\d+),\s*(\d+)/);
            if (matches) {
                [, r, g, b] = matches.map(Number);
            }
        } else {
            // Use default color if format not recognized
            return "#ffffff";
        }
        
        // Calculate perceived brightness (using luminance formula)
        const brightness = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
        
        // If color is too dark, boost its brightness
        if (brightness < 0.5) {
            // Increase brightness while keeping the color's hue
            const factor = Math.min(1.0, 0.7 / brightness);
            r = Math.min(255, Math.floor(r * factor));
            g = Math.min(255, Math.floor(g * factor));
            b = Math.min(255, Math.floor(b * factor));
            
            return `rgb(${r}, ${g}, ${b})`;
        }
        
        // Color is bright enough, return original
        return color;
    } catch (e) {
        console.error("Error processing color:", e);
        return "#ffffff"; // Default to white on error
    }
}


function syncPlayerStatsToFirebase(options = {}) {
    if (!playerStats.firebaseId) return;
    
    // Clean and validate data before sending to Firebase
    const statsToSync = {
        name: playerStats.name || "Anonymous",
        tpm: isNaN(playerStats.tpm) ? 0 : Math.min(9999, playerStats.tpm),
        targetsDestroyed: playerStats.targetsDestroyed || 0,
        allTimeTargetsDestroyed: playerStats.allTimeTargetsDestroyed || playerStats.targetsDestroyed || 0,
        totalPlayTimeSeconds: playerStats.totalPlayTimeSeconds || 0,
        lastActive: firebase.firestore.FieldValue.serverTimestamp(),
        color: playerStats.color || "#5c5c5c"
    };
    
    // Only include roundsWon if we're not skipping the increment
    if (!options.skipRoundIncrement) {
        statsToSync.roundsWon = playerStats.roundsWon || 0;
    }
    
    // Add better error handling
    db.collection("players").doc(playerStats.firebaseId).set(
        statsToSync, 
        { merge: true }
    ).catch(error => {
        console.error("Error updating player data:", error);
        console.log("Attempted to save:", JSON.stringify(statsToSync));
    });
}

// Update function for enemy pilot stats
function updateEnemyPilotStats(pilot) {
    if (!pilot) return;
    
    // Calculate TPM
    pilot.tpm = calculateTPM(pilot.targetsDestroyed, pilot.totalPlayTimeSeconds || 1);
    
    // CRITICAL FIX: Update the corresponding leaderboard entry directly
    const leaderboardIndex = leaderboard.findIndex(entry => entry.id === pilot.id);
    if (leaderboardIndex >= 0) {
        leaderboard[leaderboardIndex].targetsDestroyed = pilot.targetsDestroyed;
        leaderboard[leaderboardIndex].tpm = pilot.tpm;
        console.log(`Updated leaderboard for ${pilot.name}: ${pilot.targetsDestroyed} kills`);
    } else {
        // If pilot isn't in leaderboard, add them
        leaderboard.push({
            id: pilot.id,
            name: pilot.name,
            targetsDestroyed: pilot.targetsDestroyed,
            tpm: pilot.tpm,
            color: pilot.color || "#66ccff",
            isEnemyPilot: true
        });
        console.log(`Added ${pilot.name} to leaderboard with ${pilot.targetsDestroyed} kills`);
    }
    
    // Force immediate UI update
    updateLeaderboard();
}




function optimizeBuildingMaterials() {
    buildings.forEach(building => {
        // Distance to camera
        const distance = camera.position.distanceTo(building.position);
        
        if (distance > 200) {
            // Use simple material for distant buildings
            if (building.material.type !== 'MeshLambertMaterial') {
                const color = building.material.color;
                disposeObject(building.material);
                building.material = new THREE.MeshLambertMaterial({
                    color: color
                });
            }
        }
    });
}

function startGlobalScorchTimer() {
    // Don't create multiple timers
    if (globalScorchTimer) return;
    
    // Set up interval to update scorch effects
    globalScorchTimer = setInterval(() => {
        // Update ember effects for all scorch marks
        updateScorchEffects();
        
        // Clear timer if no more scorch marks
        if (scorchMarks.length === 0) {
            clearInterval(globalScorchTimer);
            globalScorchTimer = null;
        }
    }, globalScorchInterval);
}

function updatePhysics(timeStep) {
    // Update missile physics at fixed intervals
    if (gameActive && !launchAnimation && resetDelay <= 0 && missile.visible) {

         // Update player missile position
        tempVec3.copy(missileDirection).multiplyScalar(velocity * timeStep * 60);
        missile.position.add(tempVec3);
                
        // Update enemy missiles physics
        enemyMissiles.forEach(enemyMissile => {
            tempVec4.copy(enemyMissile.userData.direction).multiplyScalar(
            enemyMissile.userData.speed * timeStep * 60
        );
        enemyMissile.position.add(tempVec4);
        });
        
        // Update explosion particles with physics
        for (let i = explosionParticles.length - 1; i >= 0; i--) {
            const particle = explosionParticles[i];
            tempVec4.copy(particle.userData.velocity).multiplyScalar(timeStep * 10);
            particle.position.add(tempVec4);
            
            // Apply simple gravity to debris
            if (particle.userData.rotationSpeed) {
                particle.rotation.x += particle.userData.rotationSpeed.x * timeStep * 60;
                particle.rotation.y += particle.userData.rotationSpeed.y * timeStep * 60;
                particle.rotation.z += particle.userData.rotationSpeed.z * timeStep * 60;
                
                // Add gravity
                particle.userData.velocity.y -= 9.8 * timeStep;
            }
        }
    }
}

function checkGameEndConditions() {
    // Only run check if game is still active and not already in game over sequence
    if (gameActive && !window.gameOverTriggered) {
        // Check if all targets are destroyed - use both stats AND actual target building count
        const actualTargetsRemaining = targetBuildings.length;
        
        if (stats.targetsRemaining <= 0 || actualTargetsRemaining <= 0) {
            console.log("Game end check: Targets destroyed! Stats:", stats.targetsRemaining, 
                        "Actual target buildings:", actualTargetsRemaining);
            
            // Force targetRemaining to 0 to ensure consistency
            stats.targetsRemaining = 0;

            if (!window.roundAlreadyWon) {
                window.roundAlreadyWon = true;
                
                console.log("Player won round from checkGameEndConditions! Rounds won:", playerStats.roundsWon);
                
                // Show victory message if that function exists
                if (typeof showRoundVictoryMessage === 'function') {
                    showRoundVictoryMessage();
                }
                
                // Sync to Firebase with the update flag to prevent second increment
                syncPlayerStatsToFirebase({ skipRoundIncrement: true });
            }
            
            // Trigger game over sequence
            window.gameOverTriggered = true;
            gameActive = false;
            
            // Hide missile if it's somehow still visible
            if (missile && missile.visible) {
                missile.visible = false;
            }
            
            // Show game over with slight delay
            setTimeout(() => {
                showGameOver();
            }, 1000);
            
            // Cancel any pending resets
            if (resetDelay > 0) {
                resetDelay = 0;
            }
        }
    }
}


function animate(currentTime) {
    animationFrameId = requestAnimationFrame(animate);

    if (gameActive) {
        elapsedTime = Date.now() - startTime;
    }
        
    // First frame initialization
    if (!lastTime) {
        lastTime = currentTime;
        return; // Skip first frame to avoid huge delta
    }
    
    // Calculate delta time in seconds with upper limit to avoid large jumps
    const rawDelta = (currentTime - lastTime) / 1000;
    const delta = Math.min(rawDelta, 0.05); // Cap at 50ms to prevent extreme jumps
    lastTime = currentTime;

    // Update all timers
    gameTimers.leaderboard += delta;
    gameTimers.firebaseSync += delta;
    gameTimers.enemyPilotStats += delta;
    gameTimers.effects += delta;
    gameTimers.scorchCleanup++;

    // Add periodic check for game end conditions
    gameEndCheckTimer += delta;
    if (gameEndCheckTimer >= GAME_END_CHECK_INTERVAL) {
        checkGameEndConditions();
        gameEndCheckTimer = 0;
    }

    // If game is active, update game elements
    if (gameActive) {
        // Update all pilots' playtime consistently
        const playtimeIncrement = delta; // Use actual frame time
        updateOtherPlayers(delta);
        updateOtherPlayerMinimapMarkers();
        updateSpatialAudio();

        // Update player stats 
        updatePlayerStats(playtimeIncrement);

                
        // Update enemy pilot stats with the same delta
        enemyPilotStats.forEach(pilot => {
            pilot.totalPlayTimeSeconds += playtimeIncrement;
            pilot.tpm = calculateTPM(pilot.targetsDestroyed, pilot.totalPlayTimeSeconds);
        });
        
        // Update leaderboard every 1 second
        if (gameTimers.leaderboard >= 1.0) {
            updateLeaderboard();
            gameTimers.leaderboard = 0;
        }
        
        // Sync to Firebase periodically
        if (gameTimers.firebaseSync >= FIREBASE_SYNC_INTERVAL) {
            syncPlayerStatsToFirebase();
            gameTimers.firebaseSync = 0;
        }
        
        // Handle gameplay logic
        if (launchAnimation) {
            handleLaunchAnimation(delta);
        } 
        else if (resetDelay > 0) {
            handleResetDelay(delta);
        } 
        else {
            updateMissile(delta);
            updateCamera(delta);
            checkCollisions();
        }
    }
    
    // Update portal shader times and explosion effects
    if (gameTimers.effects >= 0.016) { // Limit to 60fps for these operations
        updatePortalMaterials(gameTimers.effects);
        
        // Update shader time for explosion particles
        const shaderTime = performance.now() * 0.001;
        for (let i = 0; i < explosionParticles.length; i++) {
            const particle = explosionParticles[i];
            if (particle.material && particle.material.uniforms && particle.material.uniforms.time) {
                particle.material.uniforms.time.value = shaderTime;
            }
        }
        
        gameTimers.effects = 0;
    }
    
    // Always update particles, HUD, missiles and minimap
    updateParticles(delta);
    updateHUD();
    updateEnemyMissiles(delta);
    updateMinimap();
    updateOtherPlayers(delta);
    
    // Update smoke and clean up scorch marks less frequently
    updateScorchMarks(delta);
    updateDamagedBuildingsSmoke();

    updatePlayerStats(delta); // Update player stats every frame
    
    // Clean up scorch marks every 30 frames
    if (gameTimers.scorchCleanup >= 30) {
        cleanupScorchMarks();
        gameTimers.scorchCleanup = 0;
    }
    
    updatePhysics(delta);
    
    // Apply screen shake
    if (screenShakeTime > 0) {
        const intensity = screenShakeIntensity * screenShakeTime;
        cameraShakeOffset.set(
            (Math.random() - 0.5) * intensity,
            (Math.random() - 0.5) * intensity,
            (Math.random() - 0.5) * intensity
        );
        camera.position.add(cameraShakeOffset);
        camera.position.sub(cameraShakeOffset);
        
        screenShakeTime -= delta;
    }
    
    // Render the scene
    renderer.render(scene, camera);
}



function handleLaunchAnimation(delta) {
    launchAnimationTime += delta;
    // Play sound once at beginning of launch
    if (launchAnimationTime <= delta) { // Will trigger on first frame only
        playSound('missile');
        // Ensure camera up vector is reset at the very start of launch
        camera.up.set(0, 1, 0);
    }

    if (launchAnimationTime >= launchAnimationDuration) {
        // Animation complete
        launchAnimation = false;
        startFlightSound();
        hideControlsOverlay(); // Hide controls when player takes control
        velocity = baseVelocity;

        smoothedCameraPosition.copy(camera.position);
        
        // Calculate what the camera is currently looking at
        const tempLookDir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
        smoothedCameraLookAt.copy(missile.position);
    } else {
        // Calculate animation progress (0 to 1)
        const progress = launchAnimationTime / launchAnimationDuration;
        
        // Starting position (far behind missile)
        const startPosition = missile.position.clone().sub(
            missileDirection.clone().multiplyScalar(50)
        );
        startPosition.y += 20; // Higher up
        
        // End position (normal camera offset)
        const endPosition = missile.position.clone().sub(
            missileDirection.clone().multiplyScalar(cameraOffset.z)
        );
        endPosition.y += cameraOffset.y;
        
        // Interpolate between start and end positions
        camera.position.lerpVectors(startPosition, endPosition, progress);
        
        // Always look at missile during animation with a level up vector
        camera.lookAt(missile.position);
        camera.up.set(0, 1, 0); // Keep camera level during animation
        
        // Update missile position/direction but don't update camera in updateMissile
        const originalCameraPos = camera.position.clone();
        updateMissile(delta);
        camera.position.copy(originalCameraPos);
    }
}
    
function handleResetDelay(delta) {
    // Decrease reset delay timer
    resetDelay -= delta;
    
    // When timer reaches zero or goes negative, reset the missile
    if (resetDelay <= 0) {
        // IMPORTANT: Force resetDelay to be exactly 0 to prevent floating point issues
        resetDelay = 0;
        
        // Only reset missile if it's not visible
        if (!missile.visible) {
            // Double-check that we're not in a game over state
            if (gameActive) {
                console.log("Resetting missile");
                resetMissile();
                
                // Ensure missile is visible
                missile.visible = true;
                
                // Reset any crash handling state
                if (typeof handleCrash.inProgress !== 'undefined') {
                    handleCrash.inProgress = false;
                }
                
                // FIXED: Camera position and orientation reset with perfectly level view
                // Calculate exact camera position behind missile
                const exactCameraPos = missile.position.clone().sub(
                    missileDirection.clone().multiplyScalar(cameraOffset.z)
                );
                exactCameraPos.y += cameraOffset.y;
                
                // Calculate exact look target in front of missile
                const exactLookTarget = missile.position.clone().add(
                    missileDirection.clone().multiplyScalar(10)
                );
                
                // Set camera position
                camera.position.copy(exactCameraPos);
                
                // CRITICAL FIX: Explicitly set world-up vector for perfect level orientation
                camera.up.set(0, 1, 0);
                
                // Look at target with the level orientation
                camera.lookAt(exactLookTarget);
                
                // Update smoothed positions to match exactly
                smoothedCameraPosition.copy(exactCameraPos);
                smoothedCameraLookAt.copy(exactLookTarget);
                
                // Start flight sound for the new missile
                playSound('missile');
                startFlightSound();
            }
        }
    }
}
    
    </script>
</body>
</html>
